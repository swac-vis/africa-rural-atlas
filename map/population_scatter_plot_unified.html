<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Africa Population Distribution</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            overflow: hidden;
        }
        .container {
            width: 100vw;
            height: 100vh;
            background-color: white;
            display: flex;
            flex-direction: column;
        }
        h1 {
            text-align: center;
            color: #333;
            margin: 10px 0;
            font-size: clamp(16px, 3vw, 24px);
            padding: 0 10px;
        }
        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
            margin-bottom: 15px;
            padding: 20px 24px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            flex-wrap: wrap;
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 9998;
        }
        
        /* ç¼©æ”¾æ§åˆ¶æ ·å¼ */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: row;
            gap: 5px;
            z-index: 9997;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .zoom-btn:hover {
            background: #f0f0f0;
            border-color: #999;
        }
        
        .zoom-btn:active {
            transform: scale(0.95);
        }
        
        .zoom-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* å›¾ä¾‹ä¸­çš„SVGå›¾ä¾‹æ ·å¼ */
        .figure-container {
            
        }
        
        .figure-container foreignObject {
            overflow: visible;
        }
        
        .figure-container svg {
            display: block;
            max-width: 100%;
            height: auto;
        }
        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 18px;
            margin-bottom: 15px;
            padding: 10px 18px;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 8px;
            border: 1px solid #e9ecef;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-group label {
            font-weight: 500;
            font-size: 12px;
            color: #495057;
            white-space: nowrap;
            letter-spacing: 0.3px;
        }
        
        /* åŸºç¡€æ ·å¼ */
        .control-group input {
            padding: 4px 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 12px;
            background-color: white;
            transition: all 0.2s ease;
            min-width: 80px;
            position: relative;
        }
        
        .control-group input:hover {
            border-color: #adb5bd;
        }
        
        .control-group input:focus {
            outline: none;
            border-color: #2E86AB;
            box-shadow: 0 0 0 2px rgba(46, 134, 171, 0.1);
        }
        
        /* Select ä¸“ç”¨æ ·å¼ - ä½¿ç”¨æ›´é«˜ä¼˜å…ˆçº§ */
        .control-group select {
            padding: 6px 10px;
            border: 2px solid #e9ecef;
            border-radius: 4px;
            font-size: 13px;
            background-color: white;
            transition: all 0.3s ease;
            min-width: 80px;
            position: relative;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 16px;
            padding-right: 28px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            text-indent: 2px;
            font-weight: 500;
            color: #374151;
            letter-spacing: 0.025em;
        }
        
        .control-group select:hover {
            border-color: #d1d5db;
            background-color: #fafbfc;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .control-group select:active {
            background-color: #f8f9fa;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .control-group select:focus {
            outline: none;
            border-color: #2E86AB;
            box-shadow: 0 0 0 3px rgba(46, 134, 171, 0.15), 0 4px 8px rgba(0, 0, 0, 0.1);
            background-color: white;
        }
        
        /* å°è¯•è‡ªå®šä¹‰ä¸‹æ‹‰é€‰é¡¹æ ·å¼ï¼ˆéƒ¨åˆ†æµè§ˆå™¨æ”¯æŒï¼‰ */
        .control-group select option {
            background-color: white !important;
            color: #374151 !important;
            font-size: 13px !important;
            padding: 12px 16px !important;
            border: none !important;
            font-weight: 400 !important;
            transition: all 0.2s ease !important;
        }
        
        .control-group select option:hover {
            background-color: #f3f4f6 !important;
            color: #1f2937 !important;
        }
        
        .control-group select option:checked {
            background: linear-gradient(135deg, #2E86AB 0%, #1e5a7a 100%) !important;
            color: white !important;
            font-weight: 600 !important;
        }
        
        .control-group select option:selected {
            background: linear-gradient(135deg, #2E86AB 0%, #1e5a7a 100%) !important;
            color: white !important;
            font-weight: 600 !important;
        }
        
        /* ä¸ºä¸åŒæµè§ˆå™¨æ·»åŠ ç‰¹å®šæ ·å¼ */
        .control-group select::-ms-expand {
            display: none;
        }
        
        /* Firefox ç‰¹å®šæ ·å¼ */
        .control-group select:-moz-focusring {
            color: transparent;
            text-shadow: 0 0 0 #374151;
        }
        
        /* æ·»åŠ ä¸‹æ‹‰æ¡†çš„ç„¦ç‚¹æŒ‡ç¤ºå™¨ */
        .control-group select:focus-visible {
            outline: 2px solid #2E86AB;
            outline-offset: 2px;
        }
        
        /* ä¸ºä¸‹æ‹‰æ¡†æ·»åŠ æ ‡ç­¾æ ·å¼ */
        .control-group label {
            font-weight: 600;
            font-size: 13px;
            color: #374151;
            white-space: nowrap;
            letter-spacing: 0.025em;
            margin-bottom: 4px;
            display: block;
        }
        
        /* æ§åˆ¶ç»„å®¹å™¨æ ·å¼ä¼˜åŒ– */
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 6px;
            min-width: 100px;
            position: relative;
            z-index: 9999;
        }
        
        /* ä¸‹æ‹‰æ¡†å¢å¼ºæ ·å¼ */
        .control-group select {
            position: relative;
            overflow: hidden;
        }
        
        /* æ·»åŠ ä¸‹æ‹‰æ¡†çš„æ¸å˜è¾¹æ¡†æ•ˆæœ */
        .control-group select::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 6px;
            padding: 2px;
            background: linear-gradient(135deg, #2E86AB, #1e5a7a);
            -webkit-mask: 
                linear-gradient(#fff 0 0) content-box, 
                linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .control-group select:focus::before {
            opacity: 1;
        }
        
        /* ä¸ºä¸‹æ‹‰æ¡†æ·»åŠ å†…éƒ¨é˜´å½±æ•ˆæœ */
        .control-group select {
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.8),
                0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        /* ä¸‹æ‹‰æ¡†æ‚¬åœæ—¶çš„å¾®å¦™åŠ¨ç”» */
        .control-group select:hover {
            animation: selectHover 0.3s ease forwards;
        }
        
        @keyframes selectHover {
            0% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
            100% { transform: translateY(-1px); }
        }
        
        /* ä¸ºä¸åŒçŠ¶æ€çš„ä¸‹æ‹‰æ¡†æ·»åŠ ä¸åŒçš„è¾¹æ¡†é¢œè‰² */
        .control-group select:invalid {
            border-color: #ef4444;
        }
        
        .control-group select:valid {
            border-color: #10b981;
        }
        
        /* å“åº”å¼è®¾è®¡ä¼˜åŒ– */
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                gap: 16px;
                padding: 16px 20px;
            }
            
            .control-group {
                min-width: 100%;
                align-items: center;
            }
            
            .control-group select {
                min-width: 200px;
                text-align: center;
            }
        }
        
        /* Range input æ ·å¼ */
        .control-group input[type="range"] {
            width: 70px;
            height: 4px;
            border-radius: 2px;
            background: linear-gradient(to right, #dee2e6 0%, #dee2e6 100%);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #2E86AB 0%, #1e5a7a 100%);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            background: linear-gradient(135deg, #1e5a7a 0%, #0d3d5a 100%);
            transform: scale(1.1);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }
        
        .control-group input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #2E86AB 0%, #1e5a7a 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .control-group span {
            font-size: 11px;
            color: #6c757d;
            min-width: 35px;
            text-align: center;
        }
        
        .chart-container {
            flex: 1;
            width: 100%;
            position: relative;
            min-height: 300px;
        }
        
        .legend {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 80px;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            z-index: 1000;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: clamp(10px, 2vw, 12px);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 200px;
            z-index: 1000;
        }
        
        /* è¯¦ç»†ä¿¡æ¯é¢æ¿æ ·å¼ */
        .detail-panel {
            position: fixed;
            right: 0;
            width: 400px;
            background: white;
            border-left: 0.5px solid #ddd;
            z-index: 9996;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .detail-panel.show {
            transform: translateX(0);
        }
        
        .detail-panel-header {
            padding: 15px 20px;
            border-bottom: 2px solid #f0f0f0;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .detail-panel-title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin: 0;
        }
        
        .detail-panel-close {
            position: absolute;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 5px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .detail-panel-close:hover {
            background: #f0f0f0;
            color: #333;
        }
        
        .detail-panel-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .detail-panel-section {
            margin-bottom: 25px;
        }
        
        .detail-panel-section h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 16px;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }
        
        .detail-panel-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
        }
        
        .detail-panel-label {
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }
        
        .detail-panel-value {
            color: #333;
            text-align: right;
            font-size: 14px;
        }
        
        .detail-panel-chart {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .detail-panel-chart h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 16px;
        }
        
        /* æ”¾å¤§è§†å›¾å®¹å™¨ */
        .zoom-view {
            width: 100%;
            height: 200px;
            background: #fff;
            border-radius: 8px;
            border: 0.5px solid #ddd;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        .zoom-view svg {
            max-width: 100%;
            max-height: 100%;
        }
        
        /* ç‚¹å‡»æ•ˆæœ */
        .cell-clickable {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .cell-clickable:hover {
            filter: brightness(1.2) drop-shadow(0 0 8px rgba(0, 0, 0, 0.3));
        }
        
        .cell-clickable:hover circle {
            stroke: #0b4eca;
            stroke-width: 1;
        }
        
        .cell-clickable.selected {
            filter: brightness(1.1) drop-shadow(0 0 6px rgba(11, 78, 202, 0.3));
        }
        
        .cell-clickable.selected circle {
            stroke: #0b4eca;
            stroke-width: 1;
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            .control-group {
                flex-direction: column;
                align-items: flex-start;
            }
            h1 {
                font-size: 18px;
                margin: 5px 0;
            }
            .detail-panel {
                width: 100%;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 16px;
                margin: 3px 0;
            }
            .detail-panel {
                width: 100%;
            }
        }
        
        /* è‡ªå®šä¹‰ä¸‹æ‹‰æ¡†æ ·å¼ */
        .custom-select {
            position: relative;
            display: inline-block;
            font-family: inherit;
            z-index: 9999;
            min-width: 80px;
        }
        
        .select-display {
            padding: 6px 10px;
            border: 2px solid #e9ecef;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            user-select: none;
            position: relative;
            font-size: 13px;
            font-weight: 500;
            color: #374151;
            letter-spacing: 0.025em;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            min-width: 80px;
            max-width: 120px;
        }
        
        .select-display:hover {
            border-color: #d1d5db;
            background-color: #fafbfc;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .select-display:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .select-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e9ecef;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .select-option {
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 1px solid #f3f4f6;
            font-size: 13px;
            color: #374151;
        }
        
        .select-option:hover {
            background-color: #f3f4f6;
            color: #1f2937;
        }
        
        .select-option:last-child {
            border-bottom: none;
        }
        
        /* æ»šåŠ¨æ¡æ ·å¼ */
        .select-options::-webkit-scrollbar {
            width: 6px;
        }
        
        .select-options::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        .select-options::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }
        
        .select-options::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        
        /* Z-Index å±‚çº§ç³»ç»Ÿ
         * 9999: è‡ªå®šä¹‰ä¸‹æ‹‰æ¡†é€‰é¡¹åˆ—è¡¨ (æœ€é«˜ä¼˜å…ˆçº§)
         * 9998: æ§åˆ¶ç»„å®¹å™¨
         * 9997: æ§åˆ¶é¢æ¿ (.controls)
         * 9996: ç¼©æ”¾æ§åˆ¶æŒ‰é’® (.zoom-controls)
         * 9995: è¯¦ç»†ä¿¡æ¯é¢æ¿ (.detail-panel)
         * 1000: å›¾ä¾‹ (.legend) å’Œå·¥å…·æç¤º (.tooltip)
         * 100: åœ°å›¾å…ƒç´ å’Œå…¶ä»–åŸºç¡€ç»„ä»¶
         */
        
        /* ç¡®ä¿ä¸‹æ‹‰æ¡†åœ¨æ‰€æœ‰å…ƒç´ ä¹‹ä¸Š */
        .custom-select,
        .select-display,
        .select-options,
        .select-option {
            position: relative;
            z-index: 9999 !important;
        }
        
        /* ç¡®ä¿æ§åˆ¶é¢æ¿åœ¨æ­£ç¡®å±‚çº§ */
        .controls {
            z-index: 9997 !important;
        }
        
        .control-group {
            z-index: 9998 !important;
        }
        
        /* ç¡®ä¿ç¼©æ”¾æ§åˆ¶ä¸ä¼šé®æŒ¡ä¸‹æ‹‰æ¡† */
        .zoom-controls {
            z-index: 9996 !important;
        }
        
        /* ç¡®ä¿è¯¦ç»†ä¿¡æ¯é¢æ¿ä¸ä¼šé®æŒ¡ä¸‹æ‹‰æ¡† */
        .detail-panel {
            z-index: 9995 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Africa Population Distribution</h1>
        <div class="controls">
            <div class="control-group">
                <label>Grid Size:</label>
                <select id="gridSize">
                    <option value="100">100km</option>
                    <option value="1000">1000km</option>
                </select>
            </div>
            <div class="control-group">
                <label>Color Mapping:</label>
                <select id="colorMapping">
                    <option value="density">Density</option>
                    <option value="population">Population</option>
                </select>
            </div>
            <div class="control-group">
                <label>Visualization Mode:</label>
                <select id="visualizationMode">
                    <option value="scatter">Scatter Plot</option>
                    <option value="concentric">Concentric Circles</option>
                    <option value="rect">Rectangle</option>
                </select>
            </div>
            <div class="control-group">
                <label>Area Data:</label>
                <select id="areaData">
                    <option value="true">Use Real Area</option>
                    <option value="false">Use Fixed Area</option>
                </select>
            </div>
            <div class="control-group">
                <label>Circle Size:</label>
                <input type="range" id="circleSize" min="0.1" max="0.6" step="0.1" value="0.2">
                <span id="circleSizeValue">0.2</span>
            </div>
            <div class="control-group">
                <label>Circle Spacing:</label>
                <input type="range" id="circleSpacing" min="0.3" max="1.2" step="0.1" value="0.4">
                <span id="circleSpacingValue">0.4</span>
            </div>
            <div class="control-group">
                <label>Max Circles per Cell:</label>
                <input type="range" id="maxCircles" min="1" max="256" step="1" value="16">
                <span id="maxCirclesValue">16</span>
            </div>
        </div>
        <div class="chart-container" id="chart">
            <!-- ç¼©æ”¾æ§åˆ¶æŒ‰é’® -->
            <div class="zoom-controls">
                <button class="zoom-btn" id="resetZoomBtn" title="é‡ç½®ç¼©æ”¾">âŒ‚</button>
            </div>
        </div>
    </div>

    <!-- è¯¦ç»†ä¿¡æ¯å³ä¾§é¢æ¿ -->
    <div class="detail-panel" id="detailPanel">
        <div class="detail-panel-header">
            <h2 class="detail-panel-title" id="detailPanelTitle">Cell Details</h2>
            <button class="detail-panel-close" id="closeDetailPanelBtn">&times;</button>
        </div>
        <div class="detail-panel-content">
            <div class="zoom-view" id="zoomView">
                <!-- æ”¾å¤§çš„ç½‘æ ¼å•å…ƒå°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
            </div>
            <div class="detail-panel-section" id="detailPanelGrid">
                <!-- è¯¦ç»†ä¿¡æ¯å°†é€šè¿‡JavaScriptåŠ¨æ€å¡«å…… -->
            </div>
        </div>
    </div>

    <script>
        // åŠ¨æ€è®¾ç½®detail panelä½ç½®
        function updateDetailPanelPosition() {
            const detailPanel = document.getElementById('detailPanel');
            const header = document.querySelector('h1');
            const controls = document.querySelector('.controls');
            
            if (detailPanel && header && controls) {
                // è·å–headerçš„å®é™…é«˜åº¦ï¼ˆåŒ…æ‹¬marginï¼‰
                const headerRect = header.getBoundingClientRect();
                const headerBottom = headerRect.bottom;
                
                // è·å–controlsçš„å®é™…é«˜åº¦ï¼ˆåŒ…æ‹¬borderï¼‰
                const controlsRect = controls.getBoundingClientRect();
                const controlsBottom = controlsRect.bottom;
                
                // ä½¿ç”¨controlsçš„åº•éƒ¨ä½ç½®ä½œä¸ºdetail panelçš„é¡¶éƒ¨ä½ç½®
                detailPanel.style.top = controlsBottom + 'px';
                detailPanel.style.height = `calc(100vh - ${controlsBottom}px)`;
            }
        }

        // é…ç½®å‚æ•°
        let currentConfig = {
            gridSize: '100',
            useRealArea: true,
            colorMapping: 'density',
            circleSize: 0.2,  // 100kmé»˜è®¤å€¼
            circleSpacing: 0.4,  // 100kmé»˜è®¤å€¼
            maxCircles: 16,  // é»˜è®¤å€¼
            visualizationMode: 'scatter'  // æ–°å¢ï¼šå¯è§†åŒ–æ¨¡å¼
        };

        // ç¼©æ”¾ç›¸å…³å˜é‡
        let currentZoom = d3.zoomIdentity;
        let zoomLevel = 1;
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 10;

        // ç”¨æˆ·è‡ªå®šä¹‰é¢œè‰²è®¾ç½®
        let customColorSettings = {
            population: {
                thresholds: currentConfig.gridSize === '1000' ? 
                    [100000, 500000, 1500000, 5000000, 10000000, 30000000] :
                    [1000, 5000, 15000, 50000, 100000, 300000],
                colors: ["#F7F7F7", "#E4E2BD", "#D7D394", "#BC8D42", "#A5682F", "#823624", "#501E1D"]
            },
            density: {
                thresholds: [1, 5, 15, 50, 100, 300],
                colors: ["#F7F7F7", "#E4E2BD", "#D7D394", "#BC8D42", "#A5682F", "#823624", "#501E1D"]
            }
        };

        // åŠ¨æ€è®¾ç½®ç«¯ç‚¹å€¼å‡½æ•°
        function getDynamicEndpoint(gridData, colorMapping) {
            if (!gridData || gridData.length === 0) return 1000;
            
            let maxValue = 0;
            if (colorMapping === 'population') {
                maxValue = Math.max(...gridData.map(cell => 
                    Math.max(cell.urban_population || 0, cell.rural_population || 0)
                ));
            } else {
                // density mapping
                maxValue = Math.max(...gridData.map(cell => {
                    const urbanDensity = cell.urban_population && cell.urban_area ? 
                        cell.urban_population / cell.urban_area : 0;
                    const ruralDensity = cell.rural_population && cell.rural_area ? 
                        cell.rural_population / cell.rural_area : 0;
                    return Math.max(urbanDensity, ruralDensity);
                }));
            }
            
            // å¦‚æœæœ€å¤§å€¼å°äºç­‰äº300ï¼Œè®¾ç½®ä¸€ä¸ªåˆç†çš„é»˜è®¤å€¼
            if (maxValue <= 300) {
                return colorMapping === 'population' ? 1000000 : 1000;
            }
            
            // è¿”å›ä¸€ä¸ªæ¯”æœ€å¤§å€¼ç¨å¤§çš„å€¼ï¼Œç¡®ä¿>300çš„åŒºé—´èƒ½å¤Ÿæ˜¾ç¤º
            return Math.ceil(maxValue * 1.2);
        }

        // æŠ½è±¡æ˜ å°„ç­–ç•¥å‚æ•°
        const MAPPING_CONFIG = {
            maxCircles: 16,  // é»˜è®¤å€¼ï¼Œä¼šä»currentConfigè·å–
            urbanAreaShare: 0.2,
            ruralAreaShare: 0.8
        };

        // å“åº”å¼å‡½æ•°
        function getResponsiveDimensions() {
            const container = document.querySelector('.chart-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // æ ¹æ®gridSizeè°ƒæ•´åŒºåŸŸå¤§å°
            const sizeMultiplier = currentConfig.gridSize === '100' ? 0.15 : 1;
            const baseAreaSize = Math.min(width, height) * sizeMultiplier;
            const areaSize = currentConfig.gridSize === '100' 
                ? Math.max(4, Math.min(15, baseAreaSize))
                : Math.max(20, Math.min(65, baseAreaSize));
            
            return { width, height, areaSize };
        }

        // è®¡ç®—æ¯ä¸ªç½‘æ ¼çš„åœ†å½¢æ•°é‡
        function calculateCircleCount(population, minPop, maxPop) {
            if (maxPop === minPop) return 1;
            
            const normalizedPop = (population - minPop) / (maxPop - minPop);
            const rawCount = normalizedPop * MAPPING_CONFIG.maxCircles;
            const sqrtCount = Math.sqrt(rawCount);
            const roundedSqrt = Math.floor(sqrtCount);
            const circleCount = Math.max(1, roundedSqrt * roundedSqrt);
            
            return circleCount;
        }

        // åœ¨å›ºå®šåŒºåŸŸå†…ç”Ÿæˆåœ†å½¢ä½ç½®
        function generateCirclePositionsInFixedArea(circleCount, centerX, centerY, areaSize) {
            const positions = [];
            const gridSize = Math.ceil(Math.sqrt(circleCount));
            
            const circleRadius = (areaSize / gridSize) * currentConfig.circleSize;
            const spacing = (areaSize / gridSize) * currentConfig.circleSpacing;
            
            const allPositions = [];
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x = centerX - areaSize/2 + (j + 0.5) * spacing;
                    const y = centerY - areaSize/2 + (i + 0.5) * spacing;
                    allPositions.push({ x, y, i, j });
                }
            }
            
            const centerI = Math.floor(gridSize / 2);
            const centerJ = Math.floor(gridSize / 2);
            allPositions.sort((a, b) => {
                const distA = Math.sqrt((a.i - centerI) ** 2 + (a.j - centerJ) ** 2);
                const distB = Math.sqrt((b.i - centerI) ** 2 + (b.j - centerJ) ** 2);
                return distA - distB;
            });
            
            for (let idx = 0; idx < circleCount; idx++) {
                const pos = allPositions[idx];
                positions.push({ 
                    x: pos.x, 
                    y: pos.y, 
                    radius: circleRadius, 
                    spiralIndex: idx 
                });
            }
            
            return positions;
        }

        // è®¡ç®—å¯†åº¦æˆ–äººå£å€¼
        function calculateValue(cell, isUrban) {
            if (currentConfig.colorMapping === 'population') {
                return isUrban ? cell.urban_population : cell.rural_population;
            } else {
                // density mapping - æ— è®ºæ˜¯å¦ä½¿ç”¨çœŸå®é¢ç§¯ï¼Œéƒ½åº”è¯¥ç”¨çœŸå®çš„å¯†åº¦å€¼
                const area = isUrban ? cell.urban_area : cell.rural_area;
                const population = isUrban ? cell.urban_population : cell.rural_population;
                return area > 0 ? population / area : 0;
            }
        }

        // åˆ›å»ºé¢œè‰²æ¯”ä¾‹å°º
        function createColorScale(gridData) {
            // ä½¿ç”¨ç”¨æˆ·è‡ªå®šä¹‰çš„é¢œè‰²è®¾ç½®
            const settings = customColorSettings[currentConfig.colorMapping];
            
            // è·å–åŠ¨æ€ç«¯ç‚¹å€¼
            const dynamicEndpoint = getDynamicEndpoint(gridData, currentConfig.colorMapping);
            
            // åˆ›å»ºæ‰©å±•çš„é˜ˆå€¼æ•°ç»„ï¼ŒåŒ…å«åŠ¨æ€ç«¯ç‚¹
            const extendedThresholds = [...settings.thresholds, dynamicEndpoint];
            
            // åˆ›å»ºè‡ªå®šä¹‰çš„é¢œè‰²æ¯”ä¾‹å°ºï¼Œæ”¯æŒåŒºé—´å†…éƒ¨çš„çº¿æ€§æ’å€¼
            const colorScale = function(value) {
                if (value <= 0) return settings.colors[0];
                
                // æ‰¾åˆ°å€¼æ‰€åœ¨çš„åŒºé—´
                for (let i = 0; i < extendedThresholds.length; i++) {
                    if (value <= extendedThresholds[i]) {
                        if (i === 0) {
                            // ç¬¬ä¸€ä¸ªåŒºé—´ï¼š0 åˆ°ç¬¬ä¸€ä¸ªé˜ˆå€¼
                            const ratio = value / extendedThresholds[i];
                            return d3.interpolateRgb(settings.colors[0], settings.colors[1])(ratio);
                        } else {
                            // å…¶ä»–åŒºé—´ï¼šåœ¨ä¸¤ä¸ªé˜ˆå€¼ä¹‹é—´
                            const prevThreshold = extendedThresholds[i - 1];
                            const currThreshold = extendedThresholds[i];
                            const ratio = (value - prevThreshold) / (currThreshold - prevThreshold);
                            return d3.interpolateRgb(settings.colors[i], settings.colors[i + 1])(ratio);
                        }
                    }
                }
                
                // è¶…å‡ºæœ€å¤§é˜ˆå€¼çš„å€¼
                return settings.colors[settings.colors.length - 1];
            };
            
            return colorScale;
        }

        // åˆ›å»ºå›¾ä¾‹
        function createLegend(svg, colorScale, maxValue) {
            const legendWidth = 160; // å‡å°‘å®½åº¦ï¼Œä¿æŒæç®€
            const legendHeight = 280;

            // ç§»é™¤æ—§å›¾ä¾‹
            svg.selectAll(".legend").remove();

            const legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(20, 20)`);

            // æ·»åŠ ç¼–ç è§„åˆ™è¯´æ˜
            legend.append("text")
                .attr("x", 0)
                .attr("y", 15)
                .attr("font-size", "10px")
                .attr("font-weight", "500")
                .attr("fill", "#495057")
                .text("Visualization Rules:");

            // åŠ è½½å¹¶æ˜¾ç¤ºå¯è§†åŒ–æ¨¡å¼å›¾ä¾‹
            const figureContainer = legend.append("g")
                .attr("class", "figure-container")
                .attr("transform", "translate(0, 25)");

            // æ ¹æ®å½“å‰é…ç½®é€‰æ‹©å¯¹åº”çš„å›¾ä¾‹
            const getFigurePath = () => {
                const mode = currentConfig.visualizationMode;
                const size = currentConfig.gridSize;
                
                if (mode === 'scatter') {
                    return size === '100' ? 'figures/scatter_100.svg' : 'figures/scatter_1000.svg';
                } else if (mode === 'concentric') {
                    return size === '100' ? 'figures/concentric_100.svg' : 'figures/concentric_1000.svg';
                } else if (mode === 'rect') {
                    return size === '100' ? 'figures/rect_100.svg' : 'figures/rect_1000.svg';
                }
                return 'figures/scatter_100.svg'; // é»˜è®¤
            };

            // åˆ›å»ºå›¾ä¾‹å®¹å™¨
            const legendFigure = figureContainer.append("foreignObject")
                .attr("x", -20)
                .attr("y", 0)
                .attr("width", 400)
                .attr("height", 150);

            // åŠ è½½SVGå›¾ä¾‹
            const figurePath = getFigurePath();
            fetch(figurePath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(svgContent => {
                    // åˆ›å»ºä¸´æ—¶divæ¥è§£æSVG
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = svgContent;
                    const svgElement = tempDiv.querySelector('svg');
                    
                    if (svgElement) {
                        // è°ƒæ•´SVGå¤§å°å’Œæ ·å¼
                        svgElement.style.width = '100%';
                        svgElement.style.height = 'auto';
                        svgElement.style.maxHeight = '120px';
                        
                        // å°†SVGå†…å®¹æ’å…¥åˆ°foreignObjectä¸­
                        legendFigure.node().appendChild(svgElement);
                    } else {
                        throw new Error('SVG element not found in response');
                    }
                })
                .catch(error => {
                    console.error('Error loading figure:', error);
                    // å¦‚æœåŠ è½½å¤±è´¥ï¼Œæ˜¾ç¤ºå¤‡ç”¨æ–‡æœ¬
                    figureContainer.append("text")
                        .attr("x", 0)
                        .attr("y", 35)
                        .attr("font-size", "9px")
                        .attr("fill", "#666")
                        .text("â€¢ Visualization mode: " + currentConfig.visualizationMode);
                });

            // ä½¿ç”¨è‡ªå®šä¹‰é¢œè‰²è®¾ç½®ç”Ÿæˆsegments
            const settings = customColorSettings[currentConfig.colorMapping];
            const thresholds = settings.thresholds;
            const colors = settings.colors;
            
            // è·å–åŠ¨æ€ç«¯ç‚¹å€¼
            const dynamicEndpoint = getDynamicEndpoint(window.gridData || [], currentConfig.colorMapping);
            
            // é‡æ–°è®¾è®¡ï¼šæŠŠ0å½“ä½œç¬¬ä¸€ä¸ªé˜ˆå€¼ï¼Œä½œä¸ºç¬¬ä¸€ä¸ªåŒºé—´çš„ç«¯ç‚¹ï¼Œå¹¶æ·»åŠ åŠ¨æ€ç«¯ç‚¹
            const allThresholds = [0, ...thresholds, dynamicEndpoint]; // 0 + åŸæœ‰é˜ˆå€¼ + åŠ¨æ€ç«¯ç‚¹
            const allColors = [...colors]; // ä¿æŒåŸæœ‰é¢œè‰²æ•°ç»„
            
            // ä½¿ç”¨å…¨å±€å˜é‡å­˜å‚¨segments
            window.currentSegments = [];
            let title = currentConfig.colorMapping === 'population' ? 'Population' : 'Population/kmÂ²';
            
            // ç”Ÿæˆsegments - ç°åœ¨0æ˜¯ç¬¬ä¸€ä¸ªåŒºé—´çš„ç«¯ç‚¹
            for (let i = 0; i < allThresholds.length - 1; i++) {
                if (i === allThresholds.length - 2) {
                    // æœ€åä¸€ä¸ªåŒºé—´ï¼šå¤§äºæœ€åä¸€ä¸ªé˜ˆå€¼ï¼ˆä¿ç•™>300çš„åŒºé—´ï¼‰
                    const lastThreshold = allThresholds[allThresholds.length - 1];
                    if (lastThreshold === 300) {
                    window.currentSegments.push({ 
                            label: `>300`, 
                        color: allColors[i + 1] 
                    });
                    } else {
                        window.currentSegments.push({ 
                            label: `>${lastThreshold}`, 
                            color: allColors[i + 1] 
                        });
                    }
                } else {
                    // å…¶ä»–åŒºé—´ï¼šåœ¨ä¸¤ä¸ªé˜ˆå€¼ä¹‹é—´
                    window.currentSegments.push({ 
                        label: `${allThresholds[i]}-${allThresholds[i + 1]}`, 
                        color: allColors[i + 1] 
                    });
                }
            }

            legend.append("text")
                .attr("x", 0)
                .attr("y", 200)
                .attr("font-size", "9px")
                .attr("font-weight", "500")
                .attr("fill", "#495057")
                .text(title + " Scale:");

            // åˆ›å»ºè¿ç»­é¢œè‰²æ»‘åŠ¨æ¡ç¼–è¾‘å™¨
            const colorEditor = legend.append("g")
                .attr("class", "color-editor");
            
            // æ»‘åŠ¨æ¡çš„åŸºæœ¬è®¾ç½®ï¼ˆç«–ç€çš„ï¼‰
            const sliderWidth = 16;
            const sliderHeight = 400;
            const sliderY = 220;
            const sliderX = 0;
            
            // åˆ›å»ºæ»‘åŠ¨æ¡èƒŒæ™¯
            const sliderBackground = colorEditor.append("rect")
                .attr("x", sliderX)
                .attr("y", sliderY)
                .attr("width", sliderWidth)
                .attr("height", sliderHeight)
                .attr("fill", "#f8f9fa")
                .attr("stroke", "#e9ecef")
                .attr("stroke-width", 1)
                .attr("rx", 2);
            
            // åˆ›å»ºæ¸å˜èƒŒæ™¯ï¼ˆç«–ç€çš„ï¼‰
            const gradient = colorEditor.append("defs")
                .append("linearGradient")
                .attr("id", "colorGradient")
                .attr("x1", "0%")
                .attr("y1", "100%")
                .attr("x2", "0%")
                .attr("y2", "0%");
            
            // æ·»åŠ æ¸å˜åœæ­¢ç‚¹
            colors.forEach((color, i) => {
                const offset = (i / (colors.length - 1)) * 100;
                gradient.append("stop")
                    .attr("offset", offset + "%")
                    .attr("stop-color", color);
            });
            
            // åˆ›å»ºæ¸å˜æ»‘åŠ¨æ¡
            const gradientSlider = colorEditor.append("rect")
                .attr("x", sliderX + 1)
                .attr("y", sliderY + 1)
                .attr("width", sliderWidth - 2)
                .attr("height", sliderHeight - 2)
                .attr("fill", "url(#colorGradient)")
                .attr("rx", 1);
            
            // ç§»é™¤é¢å¤–çš„ç«¯ç‚¹ä¿®æ”¹é¢œè‰²æŒ‰é’®ï¼Œåªä¿ç•™æ»‘åŠ¨æ¡å’Œé˜ˆå€¼æ ‡è®°ç‚¹
            
            // åˆ›å»ºé˜ˆå€¼æ ‡è®°ç‚¹
            const thresholdMarkers = colorEditor.append("g")
                .attr("class", "threshold-markers");
            
            // åˆ é™¤åŸæ¥çš„èµ·å§‹ç‚¹æ ‡è®°ï¼Œå› ä¸º0ç°åœ¨æ˜¯ä¸€ä¸ªçœŸæ­£çš„é˜ˆå€¼äº†
            
            // ä¸ºæ¯ä¸ªé˜ˆå€¼åˆ›å»ºæ ‡è®°ç‚¹ï¼ˆåŒ…æ‹¬0ï¼‰
            allThresholds.forEach((threshold, i) => {
                // æ ¹æ®é¢œè‰²åœ¨æ»‘åŠ¨æ¡ä¸Šçš„ä½ç½®æ¥å®šä½æ ‡è®°ç‚¹
                // ç°åœ¨0æ˜¯ç¬¬ä¸€ä¸ªé˜ˆå€¼ï¼Œä½ç½®åœ¨åº•éƒ¨
                const colorPosition = i / (allThresholds.length - 1); // 0åˆ°1ä¹‹é—´çš„ä½ç½®
                const y = sliderY + sliderHeight - colorPosition * sliderHeight;
                
                // åˆ›å»ºæ ‡è®°ç‚¹
                const marker = thresholdMarkers.append("circle")
                    .attr("cx", sliderX + sliderWidth / 2)
                    .attr("cy", y)
                    .attr("r", 4)
                    .attr("fill", allColors[i]) // ä½¿ç”¨å¯¹åº”çš„é¢œè‰²å¡«å……æ ‡è®°ç‚¹
                    .attr("stroke", "#6c757d")
                    .attr("stroke-width", 1)
                    .style("cursor", "pointer")
                    .attr("data-threshold-index", i);
                
                // æ·»åŠ åˆ é™¤æŒ‰é’®ï¼ˆé™¤äº†ç¬¬ä¸€ä¸ªã€æœ€åä¸€ä¸ªå’ŒåŠ¨æ€ç«¯ç‚¹ï¼‰
                if (i > 0 && i < allThresholds.length - 2) {
                    const deleteBtn = thresholdMarkers.append("text")
                        .attr("x", sliderX + sliderWidth / 2 + 8)
                        .attr("y", y - 8)
                        .attr("font-size", "10px")
                        .attr("fill", "#adb5bd")
                        .style("cursor", "pointer")
                        .text("Ã—")
                        .on("click", function() {
                            // åˆ é™¤é˜ˆå€¼ï¼ˆéœ€è¦è°ƒæ•´ç´¢å¼•ï¼Œå› ä¸ºallThresholdsåŒ…å«äº†0å’ŒåŠ¨æ€ç«¯ç‚¹ï¼‰
                            const thresholdIndex = i - 1; // å‡å»0çš„ç´¢å¼•
                            if (thresholdIndex >= 0 && thresholdIndex < thresholds.length) {
                                // ä¿å­˜0çš„é¢œè‰²ï¼Œç¡®ä¿å®ƒä¸ä¼šè¢«åˆ é™¤
                                const zeroColor = colors[0];
                                
                                thresholds.splice(thresholdIndex, 1);
                                colors.splice(thresholdIndex, 1);
                                
                                // ç¡®ä¿0çš„é¢œè‰²ä¿æŒä¸å˜
                                if (colors[0] !== zeroColor) {
                                    colors[0] = zeroColor;
                                }
                                
                            updateLegendFigure();
                            updateColorScale();
                            }
                        });
                }
                
                // æ·»åŠ é˜ˆå€¼æ ‡ç­¾
                const label = thresholdMarkers.append("text")
                    .attr("x", sliderX + sliderWidth + 15)
                    .attr("y", y)
                    .attr("text-anchor", "start")
                    .attr("font-size", "9px")
                    .attr("fill", "#495057")
                    .style("cursor", i === allThresholds.length - 1 ? "default" : "pointer")
                    .text(threshold)
                    .on("click", function() {
                        // åŠ¨æ€ç«¯ç‚¹ä¸èƒ½è¢«ç¼–è¾‘æ•°å€¼ï¼Œä½†å¯ä»¥ç¼–è¾‘é¢œè‰²
                        if (i === allThresholds.length - 1) return;
                        
                        // ç¼–è¾‘é˜ˆå€¼
                        const input = document.createElement("input");
                        input.type = "number";
                        input.value = threshold;
                        input.style.position = "absolute";
                        input.style.left = (event.pageX - 10) + "px";
                        input.style.top = (event.pageY - 10) + "px";
                        input.style.width = "60px";
                        input.style.fontSize = "10px";
                        input.style.zIndex = "10000";
                        
                        input.addEventListener("change", function() {
                            const newValue = parseInt(this.value);
                            if (newValue > 0) {
                                // éœ€è¦è°ƒæ•´ç´¢å¼•ï¼Œå› ä¸ºallThresholdsåŒ…å«äº†0å’ŒåŠ¨æ€ç«¯ç‚¹
                                const thresholdIndex = i - 1; // å‡å»0çš„ç´¢å¼•
                                if (thresholdIndex >= 0 && thresholdIndex < thresholds.length) {
                                    // ä¿å­˜0çš„é¢œè‰²ï¼Œç¡®ä¿å®ƒä¸ä¼šè¢«æ”¹å˜
                                    const zeroColor = colors[0];
                                    
                                    thresholds[thresholdIndex] = newValue;
                                // é‡æ–°æ’åºé˜ˆå€¼
                                thresholds.sort((a, b) => a - b);
                                    
                                    // ç¡®ä¿0çš„é¢œè‰²ä¿æŒä¸å˜
                                    if (colors[0] !== zeroColor) {
                                        colors[0] = zeroColor;
                                    }
                                    
                                updateLegendFigure();
                                updateColorScale();
                                }
                            }
                            // å®‰å…¨åœ°ç§»é™¤è¾“å…¥æ¡†
                            if (document.body.contains(this)) {
                                document.body.removeChild(this);
                            }
                        });
                        
                        input.addEventListener("blur", function() {
                            // å»¶è¿Ÿç§»é™¤ï¼Œé¿å…ä¸changeäº‹ä»¶å†²çª
                            setTimeout(() => {
                                if (document.body.contains(this)) {
                                    document.body.removeChild(this);
                                }
                            }, 100);
                        });
                        
                        document.body.appendChild(input);
                        input.focus();
                        input.select();
                    });
                
                // æ·»åŠ é¢œè‰²é€‰æ‹©æŒ‰é’®ï¼ˆæ¯ä¸ªæ ‡è®°ç‚¹éƒ½å¯ä»¥æ‰‹åŠ¨é€‰æ‹©é¢œè‰²ï¼ŒåŒ…æ‹¬åŠ¨æ€ç«¯ç‚¹ï¼‰
                const colorBtn = thresholdMarkers.append("text")
                    .attr("x", sliderX + sliderWidth / 2 + 8)
                    .attr("y", y + 8)
                    .attr("font-size", "10px")
                    .attr("fill", "#6f42c1")
                    .style("cursor", "pointer")
                    .text("ğŸ¨")
                    .on("click", function(event) {
                        // åˆ›å»ºé¢œè‰²é€‰æ‹©å™¨
                        const colorInput = document.createElement("input");
                        colorInput.type = "color";
                        colorInput.value = colors[i];
                        colorInput.style.position = "absolute";
                        colorInput.style.left = (event.pageX - 10) + "px";
                        colorInput.style.top = (event.pageY - 10) + "px";
                        colorInput.style.zIndex = "10000";
                        
                        colorInput.addEventListener("change", function() {
                            // æ›´æ–°é¢œè‰²
                            colors[i] = this.value;
                            
                            // æ›´æ–°æ ‡è®°ç‚¹é¢œè‰²
                            marker.attr("fill", colors[i]);
                            
                            // æ›´æ–°æ¸å˜èƒŒæ™¯
                            updateGradientBackground();
                            
                            // æ›´æ–°é¢œè‰²æ¯”ä¾‹å°ºå’Œåœ°å›¾
                            updateColorScale();
                            
                            // å®‰å…¨åœ°ç§»é™¤è¾“å…¥æ¡†
                            if (document.body.contains(this)) {
                                document.body.removeChild(this);
                            }
                        });
                        
                        colorInput.addEventListener("blur", function() {
                            // å»¶è¿Ÿç§»é™¤ï¼Œé¿å…ä¸changeäº‹ä»¶å†²çª
                            setTimeout(() => {
                                if (document.body.contains(this)) {
                                    document.body.removeChild(this);
                                }
                            }, 100);
                        });
                        
                        document.body.appendChild(colorInput);
                        colorInput.focus();
                        colorInput.click();
                    });
                
                // æ·»åŠ æ‹–æ‹½åŠŸèƒ½ - ä¿®æ”¹ä¸ºè°ƒæ•´é¢œè‰²è€Œä¸æ˜¯ä½ç½®ï¼ˆåŠ¨æ€ç«¯ç‚¹ä¸èƒ½è¢«æ‹–æ‹½ï¼‰
                if (i < allThresholds.length - 1) { // åŠ¨æ€ç«¯ç‚¹ä¸èƒ½æ‹–æ‹½
                marker.call(d3.drag()
                    .on("drag", function(event) {
                        // è®¡ç®—æ‹–æ‹½ä½ç½®å¯¹åº”çš„é¢œè‰²
                        const dragY = Math.max(sliderY, Math.min(sliderY + sliderHeight, event.y));
                        const colorIndex = (sliderY + sliderHeight - dragY) / sliderHeight;
                        
                        // æ ¹æ®æ‹–æ‹½ä½ç½®åœ¨æ»‘åŠ¨æ¡ä¸Šçš„é¢œè‰²ä½ç½®æ¥ç”Ÿæˆæ–°é¢œè‰²
                        // è¿™é‡Œæˆ‘ä»¬æ ¹æ®æ»‘åŠ¨æ¡ä¸Šçš„å®é™…é¢œè‰²åˆ†å¸ƒæ¥æ’å€¼
                        if (i === 0) {
                            // ç¬¬ä¸€ä¸ªé¢œè‰²ï¼šä»æ»‘åŠ¨æ¡åº•éƒ¨åˆ°ç¬¬ä¸€ä¸ªé˜ˆå€¼ä½ç½®çš„é¢œè‰²æ’å€¼
                            const newColor = d3.interpolateRgb(colors[0], colors[1])(colorIndex);
                            colors[i] = newColor;
                        } else if (i === colors.length - 1) {
                            // æœ€åä¸€ä¸ªé¢œè‰²ï¼šä»å€’æ•°ç¬¬äºŒä¸ªé¢œè‰²åˆ°æ»‘åŠ¨æ¡é¡¶éƒ¨çš„é¢œè‰²æ’å€¼
                            const newColor = d3.interpolateRgb(colors[colors.length - 2], colors[colors.length - 1])(colorIndex);
                            colors[i] = newColor;
                        } else {
                            // ä¸­é—´é¢œè‰²ï¼šæ ¹æ®åœ¨æ»‘åŠ¨æ¡ä¸Šçš„ä½ç½®ï¼Œåœ¨ç›¸é‚»ä¸¤ä¸ªé¢œè‰²ä¹‹é—´æ’å€¼
                            const prevColor = colors[i - 1];
                            const nextColor = colors[i + 1];
                            const newColor = d3.interpolateRgb(prevColor, nextColor)(colorIndex);
                            colors[i] = newColor;
                        }
                        
                        // æ›´æ–°æ ‡è®°ç‚¹é¢œè‰²
                        marker.attr("fill", colors[i]);
                        
                        // æ›´æ–°æ¸å˜èƒŒæ™¯
                        updateGradientBackground();
                        
                        // æ›´æ–°é¢œè‰²æ¯”ä¾‹å°ºå’Œåœ°å›¾
                        updateColorScale();
                    }));
                }
            });
            
            // æ·»åŠ "æ·»åŠ é˜ˆå€¼"æŒ‰é’®
            const addButton = colorEditor.append("g")
                .style("cursor", "pointer")
                .on("click", function() {
                    // è·å–åŠ¨æ€ç«¯ç‚¹å€¼
                    const dynamicEndpoint = getDynamicEndpoint(window.gridData || [], currentConfig.colorMapping);
                    
                    // è®¡ç®—æ–°é˜ˆå€¼ä½ç½®ï¼ˆåœ¨ä¸­é—´ä½ç½®ï¼Œä½†ä¸èƒ½è¶…è¿‡åŠ¨æ€ç«¯ç‚¹ï¼‰
                    const maxThreshold = Math.max(...thresholds);
                    const midPoint = Math.round(maxThreshold / 2);
                    let newThreshold = midPoint;
                    
                    // ç¡®ä¿æ–°é˜ˆå€¼ä¸è¶…è¿‡åŠ¨æ€ç«¯ç‚¹
                    if (newThreshold >= dynamicEndpoint) {
                        newThreshold = Math.round(dynamicEndpoint * 0.8);
                    }
                    
                    // å…ˆæ’åºé˜ˆå€¼ï¼Œæ‰¾åˆ°æ­£ç¡®çš„æ’å…¥ä½ç½®
                    const sortedThresholds = [...thresholds, newThreshold].sort((a, b) => a - b);
                    const insertIndex = sortedThresholds.indexOf(newThreshold);
                    
                    // ä¸ºæ–°é˜ˆå€¼ç”Ÿæˆé¢œè‰²ï¼šåœ¨ä¸¤ä¸ªç›¸é‚»é¢œè‰²ä¹‹é—´æ’å€¼
                    let newColor;
                    if (insertIndex === 0) {
                        // å¦‚æœæ˜¯æœ€å°çš„é˜ˆå€¼ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªé¢œè‰²
                        newColor = colors[0];
                    } else if (insertIndex === sortedThresholds.length - 1) {
                        // å¦‚æœæ˜¯æœ€å¤§çš„é˜ˆå€¼ï¼Œä½¿ç”¨æœ€åä¸€ä¸ªé¢œè‰²
                        newColor = colors[colors.length - 1];
                    } else {
                        // åœ¨ä¸­é—´ä½ç½®ï¼Œåœ¨ä¸¤ä¸ªç›¸é‚»é¢œè‰²ä¹‹é—´æ’å€¼
                        const prevThreshold = sortedThresholds[insertIndex - 1];
                        const nextThreshold = sortedThresholds[insertIndex + 1];
                        const prevThresholdIndex = thresholds.indexOf(prevThreshold);
                        const nextThresholdIndex = thresholds.indexOf(nextThreshold);
                        
                        if (prevThresholdIndex >= 0 && nextThresholdIndex >= 0) {
                            const prevColor = colors[prevThresholdIndex];
                            const nextColor = colors[nextThresholdIndex];
                            newColor = d3.interpolateRgb(prevColor, nextColor)(0.5);
                        } else {
                            // å¦‚æœæ‰¾ä¸åˆ°å¯¹åº”çš„é¢œè‰²ï¼Œä½¿ç”¨é»˜è®¤é¢œè‰²
                            newColor = colors[Math.floor(colors.length / 2)];
                        }
                    }
                    
                    // ä¿å­˜0çš„é¢œè‰²ï¼Œç¡®ä¿å®ƒä¸ä¼šè¢«æ”¹å˜
                    const zeroColor = colors[0];
                    
                    // åœ¨æ­£ç¡®çš„ä½ç½®æ’å…¥æ–°é˜ˆå€¼å’Œé¢œè‰²
                    thresholds.splice(insertIndex, 0, newThreshold);
                    colors.splice(insertIndex, 0, newColor);
                    
                    // ç¡®ä¿0çš„é¢œè‰²ä¿æŒä¸å˜
                    if (colors[0] !== zeroColor) {
                        colors[0] = zeroColor;
                    }
                    
                    // é‡æ–°åˆ›å»ºå›¾ä¾‹å’Œæ›´æ–°é¢œè‰²æ¯”ä¾‹å°º
                    updateLegendFigure();
                    updateColorScale();
                });
            
            addButton.append("circle")
                .attr("cx", sliderX + sliderWidth / 2)
                .attr("cy", sliderY + sliderHeight + 25)
                .attr("r", 6)
                .attr("fill", "#222")
                .attr("stroke", "#495057")
                .attr("stroke-width", 1);
            
            addButton.append("text")
                .attr("x", sliderX + sliderWidth / 2)
                .attr("y", sliderY + sliderHeight + 28)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", "white")
                .text("+");
            
            // addButton.append("text")
            //     .attr("x", sliderX + sliderWidth / 2)
            //     .attr("y", sliderY + sliderHeight + 38)
            //     .attr("text-anchor", "middle")
            //     .attr("font-size", "8px")
            //     .attr("fill", "#6c757d")
            //     .text("Add");
            
            // åˆ é™¤é¢å¤–çš„é¢œè‰²ç¼–è¾‘æŒ‰é’®ï¼Œåªåœ¨æ»‘åŠ¨æ¡ä¸¤ç«¯æ·»åŠ é¢œè‰²é€‰æ‹©å™¨
            
            // æ·»åŠ æ›´æ–°æ¸å˜èƒŒæ™¯çš„å‡½æ•°
            function updateGradientBackground() {
                // æ¸…é™¤æ—§çš„æ¸å˜å®šä¹‰
                d3.select("#colorGradient").remove();
                
                // åˆ›å»ºæ–°çš„æ¸å˜å®šä¹‰
                const newGradient = colorEditor.append("defs")
                    .append("linearGradient")
                    .attr("id", "colorGradient")
                    .attr("x1", "0%")
                    .attr("y1", "100%")
                    .attr("x2", "0%")
                    .attr("y2", "0%");
                
                // æ·»åŠ æ¸å˜åœæ­¢ç‚¹
                colors.forEach((color, i) => {
                    const offset = (i / (colors.length - 1)) * 100;
                    newGradient.append("stop")
                        .attr("offset", offset + "%")
                        .attr("stop-color", color);
                });
                
                // æ›´æ–°æ¸å˜æ»‘åŠ¨æ¡
                gradientSlider.attr("fill", "url(#colorGradient)");
            }
                }
        
        // æ›´æ–°é¢œè‰²æ¯”ä¾‹å°ºå¹¶é‡æ–°æ¸²æŸ“åœ°å›¾
        function updateColorScale() {
            // é‡æ–°ç”Ÿæˆé¢œè‰²æ¯”ä¾‹å°º
            const colorScale = createColorScale(window.gridData || []);
            
            // æ›´æ–°æ‰€æœ‰åœ†å½¢çš„é¢œè‰²ï¼ˆscatteræ¨¡å¼ï¼‰
            d3.selectAll(".cell-clickable circle").each(function() {
                const circle = d3.select(this);
                const cellGroup = d3.select(this.parentNode);
                const cellId = cellGroup.attr("data-cell-id");
                
                // æ‰¾åˆ°å¯¹åº”çš„cellæ•°æ®
                const cell = (window.gridData || []).find(d => `${d.longitude}-${d.latitude}` === cellId);
                if (cell) {
                    // ä»cellGroupä¸­è·å–urbanCirclesä¿¡æ¯
                    const cellData = cellGroup.datum();
                    const urbanCircles = cellData ? cellData.urbanCircles : 0;
                    const isUrban = circle.datum() ? circle.datum().spiralIndex < urbanCircles : false;
                    const value = calculateValue(cell, isUrban);
                    const safeValue = isFinite(value) && value >= 0 ? value : 0;
                    circle.attr("fill", colorScale(safeValue));
                }
            });
            
            // æ›´æ–°æ‰€æœ‰çŸ©å½¢çš„é¢œè‰²ï¼ˆrectæ¨¡å¼ï¼‰
            d3.selectAll(".cell-clickable rect[width]").each(function() {
                const rect = d3.select(this);
                const cellGroup = d3.select(this.parentNode);
                const cellId = cellGroup.attr("data-cell-id");
                
                // æ‰¾åˆ°å¯¹åº”çš„cellæ•°æ®
                const cell = (window.gridData || []).find(d => `${d.longitude}-${d.latitude}` === cellId);
                if (cell) {
                    // ä»cellGroupä¸­è·å–urbanAreaRatioä¿¡æ¯
                    const cellData = cellGroup.datum();
                    const urbanAreaRatio = cellData ? cellData.urbanAreaRatio : 0;
                    
                    // åˆ¤æ–­æ˜¯å¤–çŸ©å½¢è¿˜æ˜¯å†…çŸ©å½¢
                    // æˆ‘ä»¬é€šè¿‡æ£€æŸ¥çŸ©å½¢æ˜¯å¦æ˜¯é€æ˜ç‚¹å‡»åŒºåŸŸæ¥åˆ¤æ–­
                    const isClickArea = rect.attr("fill") === "transparent";
                    if (isClickArea) return; // è·³è¿‡é€æ˜ç‚¹å‡»åŒºåŸŸ
                    
                    // æ ¹æ®çŸ©å½¢åœ¨cellGroupä¸­çš„é¡ºåºæ¥åˆ¤æ–­
                    // ç¬¬ä¸€ä¸ªçŸ©å½¢æ˜¯å¤–çŸ©å½¢ï¼ˆruralï¼‰ï¼Œç¬¬äºŒä¸ªæ˜¯å†…çŸ©å½¢ï¼ˆurbanï¼‰
                    const rects = cellGroup.selectAll("rect[width]").nodes();
                    const rectIndex = rects.indexOf(rect);
                    const isUrban = rectIndex === 1; // ç¬¬äºŒä¸ªçŸ©å½¢æ˜¯å†…çŸ©å½¢
                    
                    const value = calculateValue(cell, isUrban);
                    const safeValue = isFinite(value) && value >= 0 ? value : 0;
                    rect.attr("fill", colorScale(safeValue));
                }
            });
            
            // æ›´æ–°æ‰€æœ‰åŒå¿ƒåœ†çš„é¢œè‰²ï¼ˆconcentricæ¨¡å¼ï¼‰
            d3.selectAll(".cell-clickable circle[fill]").each(function() {
                const circle = d3.select(this);
                const cellGroup = d3.select(this.parentNode);
                const cellId = cellGroup.attr("data-cell-id");
                
                // æ‰¾åˆ°å¯¹åº”çš„cellæ•°æ®
                const cell = (window.gridData || []).find(d => `${d.longitude}-${d.latitude}` === cellId);
                if (cell) {
                    // ä»cellGroupä¸­è·å–urbanAreaRatioä¿¡æ¯
                    const cellData = cellGroup.datum();
                    const urbanAreaRatio = cellData ? cellData.urbanAreaRatio : 0;
                    
                    // åˆ¤æ–­æ˜¯å¤–åœ†è¿˜æ˜¯å†…åœ†
                    // æˆ‘ä»¬é€šè¿‡æ£€æŸ¥åœ†æ˜¯å¦æ˜¯é€æ˜ç‚¹å‡»åŒºåŸŸæ¥åˆ¤æ–­
                    const isClickArea = circle.attr("fill") === "transparent";
                    if (isClickArea) return; // è·³è¿‡é€æ˜ç‚¹å‡»åŒºåŸŸ
                    
                    // æ ¹æ®åœ†åœ¨cellGroupä¸­çš„é¡ºåºæ¥åˆ¤æ–­
                    // ç¬¬ä¸€ä¸ªåœ†æ˜¯å¤–åœ†ï¼ˆruralï¼‰ï¼Œç¬¬äºŒä¸ªæ˜¯å†…åœ†ï¼ˆurbanï¼‰
                    const circles = cellGroup.selectAll("circle[fill]").nodes();
                    const circleIndex = circles.indexOf(circle);
                    const isUrban = circleIndex === 1; // ç¬¬äºŒä¸ªåœ†æ˜¯å†…åœ†
                    
                    const value = calculateValue(cell, isUrban);
                    const safeValue = isFinite(value) && value >= 0 ? value : 0;
                    circle.attr("fill", colorScale(safeValue));
                }
            });
            
            // é‡æ–°åˆ›å»ºå›¾ä¾‹
            const svg = d3.select("#chart svg");
            const maxValue = Math.max(...(window.gridData || []).map(d => Math.max(calculateValue(d, true), calculateValue(d, false))));
            createLegend(svg, colorScale, maxValue);
            
            // å¼ºåˆ¶é‡æ–°æ¸²æŸ“
            console.log("Color scale updated:", customColorSettings[currentConfig.colorMapping]);
        }
        
        // åˆ›å»ºåŒå¿ƒåœ†æ”¾å¤§è§†å›¾
        function createConcentricZoomView(svg, cell, colorScale, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            
            // è®¡ç®—åŒå¿ƒåœ†çš„å¤§å°
            const areaSize = Math.min(width, height) * 0.6;
            const radius = currentConfig.gridSize === '100' ? areaSize * 0.5 : areaSize * 0.5;
            
            // è®¡ç®—urban areaå æ¯”ï¼ˆç”¨äºå†…åœ†å¤§å°ï¼‰
            const totalArea = cell.urban_area + cell.rural_area;
            let urbanAreaRatio;
            if (currentConfig.useRealArea) {
                // ä½¿ç”¨çœŸå®é¢ç§¯æ¯”ä¾‹
                urbanAreaRatio = totalArea > 0 ? cell.urban_area / totalArea : 0;
            } else {
                // ä½¿ç”¨å›ºå®šé¢ç§¯æ¨¡å¼ï¼šå†…åœ†å æ®20%çš„é¢ç§¯
                urbanAreaRatio = 0.2;
            }
            const innerRadius = radius * Math.sqrt(urbanAreaRatio); // å†…åœ†åŠå¾„
            
            // ç»˜åˆ¶å¤–åœ†ï¼ˆä»£è¡¨ruraläººå£ï¼‰
            const ruralValue = calculateValue(cell, false);
            const safeRuralValue = isFinite(ruralValue) && ruralValue >= 0 ? ruralValue : 0;
            
            svg.append("circle")
                .attr("cx", centerX)
                .attr("cy", centerY)
                .attr("r", radius)
                .attr("fill", colorScale(safeRuralValue))
                .attr("opacity", 0.8);
            
            // ç»˜åˆ¶å†…åœ†ï¼ˆä»£è¡¨urbanäººå£ï¼‰
            if (urbanAreaRatio > 0) {
                const urbanValue = calculateValue(cell, true);
                const safeUrbanValue = isFinite(urbanValue) && urbanValue >= 0 ? urbanValue : 0;
                
                svg.append("circle")
                    .attr("cx", centerX)
                    .attr("cy", centerY)
                    .attr("r", innerRadius)
                    .attr("fill", colorScale(safeUrbanValue))
                    .attr("opacity", 0.9);
            }
            
            // æ·»åŠ æ ‡é¢˜
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 20)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Zoomed Cell View");
        }

        // åˆ›å»ºçŸ©å½¢æ”¾å¤§è§†å›¾
        function createRectZoomView(svg, cell, colorScale, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            
            // è®¡ç®—çŸ©å½¢çš„å¤§å°
            const areaSize = Math.min(width, height) * 0.6;
            const rectSize = currentConfig.gridSize === '100' ? 
                areaSize * 1 : areaSize * 1;
            
                            // è®¡ç®—urban areaå æ¯”ï¼ˆç”¨äºå†…çŸ©å½¢å¤§å°ï¼‰
                const totalArea = cell.urban_area + cell.rural_area;
                let urbanAreaRatio;
                if (currentConfig.useRealArea) {
                    // ä½¿ç”¨çœŸå®é¢ç§¯æ¯”ä¾‹
                    urbanAreaRatio = totalArea > 0 ? cell.urban_area / totalArea : 0;
                } else {
                    // ä½¿ç”¨å›ºå®šé¢ç§¯æ¨¡å¼ï¼šå†…çŸ©å½¢å æ®20%çš„é¢ç§¯
                    urbanAreaRatio = 0.2;
                }
                const innerRectSize = rectSize * Math.sqrt(urbanAreaRatio); // å†…çŸ©å½¢å¤§å°
            
            // ç»˜åˆ¶å¤–çŸ©å½¢ï¼ˆä»£è¡¨ruraläººå£ï¼‰
            const ruralValue = calculateValue(cell, false);
            const safeRuralValue = isFinite(ruralValue) && ruralValue >= 0 ? ruralValue : 0;
            
            svg.append("rect")
                .attr("x", centerX - rectSize/2)
                .attr("y", centerY - rectSize/2)
                .attr("width", rectSize)
                .attr("height", rectSize)
                .attr("fill", colorScale(safeRuralValue))
                .attr("opacity", 0.8);
            
            // ç»˜åˆ¶å†…çŸ©å½¢ï¼ˆä»£è¡¨urbanäººå£ï¼‰
            if (urbanAreaRatio > 0) {
                const urbanValue = calculateValue(cell, true);
                const safeUrbanValue = isFinite(urbanValue) && urbanValue >= 0 ? urbanValue : 0;
                
                svg.append("rect")
                    .attr("x", centerX - innerRectSize/2)
                    .attr("y", centerY - innerRectSize/2)
                    .attr("width", innerRectSize)
                    .attr("height", innerRectSize)
                    .attr("fill", colorScale(safeUrbanValue))
                    .attr("opacity", 0.9);
            }
            
            // æ·»åŠ æ ‡é¢˜
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 20)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Zoomed Cell View");
        }
        
        // åˆ›å»ºæ”¾å¤§è§†å›¾
        function createZoomView(container, cell, circleCount, urbanCircles, ruralCircles) {
            // æ¸…é™¤ç°æœ‰å†…å®¹
            container.innerHTML = '';
            
            const width = container.clientWidth || 350;
            const height = 180;
            
            const svg = d3.select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // åˆ›å»ºé¢œè‰²æ¯”ä¾‹å°º
            const colorScale = createColorScale([cell]);
            
            // æ ¹æ®å¯è§†åŒ–æ¨¡å¼é€‰æ‹©ç»˜åˆ¶æ–¹æ³•
            if (currentConfig.visualizationMode === 'concentric') {
                // åŒå¿ƒåœ†æ¨¡å¼
                createConcentricZoomView(svg, cell, colorScale, width, height);
            } else if (currentConfig.visualizationMode === 'rect') {
                // çŸ©å½¢æ¨¡å¼
                createRectZoomView(svg, cell, colorScale, width, height);
            } else {
                // æ•£ç‚¹å›¾æ¨¡å¼ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
            
            // è®¡ç®—åœ†å½¢ä½ç½® - ä½¿ç”¨ä¸ä¸»è§†å›¾ç›¸åŒçš„å‚æ•°ä½†ç­‰æ¯”ä¾‹æ”¾å¤§
            const centerX = width / 2;
            const centerY = height / 2;
            // æ ¹æ®ç½‘æ ¼å¤§å°è°ƒæ•´æ”¾å¤§å€æ•°
            const zoomFactor = currentConfig.gridSize === '1000' ? 1 : 2.5;
            const areaSize = Math.min(width, height) * 0.6;
            
            // ä½¿ç”¨ä¸ä¸»è§†å›¾ç›¸åŒçš„ç”Ÿæˆå‡½æ•°ï¼Œä½†è°ƒæ•´å‚æ•°
            const gridSize = Math.ceil(Math.sqrt(circleCount));
            const circleRadius = (areaSize / gridSize) * currentConfig.circleSize * zoomFactor;
            const spacing = (areaSize / gridSize) * currentConfig.circleSpacing * zoomFactor;
            
            const allPositions = [];
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x = centerX - areaSize/2 + (j + 0.5) * spacing;
                    const y = centerY - areaSize/2 + (i + 0.5) * spacing;
                    allPositions.push({ x, y, i, j });
                }
            }
            
            const centerI = Math.floor(gridSize / 2);
            const centerJ = Math.floor(gridSize / 2);
            allPositions.sort((a, b) => {
                const distA = Math.sqrt((a.i - centerI) ** 2 + (a.j - centerJ) ** 2);
                const distB = Math.sqrt((b.i - centerI) ** 2 + (b.j - centerJ) ** 2);
                return distA - distB;
            });
            
            // ç»˜åˆ¶åœ†å½¢
            for (let idx = 0; idx < circleCount; idx++) {
                const pos = allPositions[idx];
                const isUrban = idx < urbanCircles;
                const value = calculateValue(cell, isUrban);
                const safeValue = isFinite(value) && value >= 0 ? value : 0;
                
                svg.append("circle")
                    .attr("cx", pos.x)
                    .attr("cy", pos.y)
                    .attr("r", circleRadius)
                    .attr("fill", colorScale(safeValue))
                    .attr("opacity", 0.9);
            }
            
            // æ·»åŠ æ ‡é¢˜
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 20)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Zoomed Cell View");
            }
        }
        
        // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯é¢æ¿
        function showDetailPanel(cell, circleCount, urbanCircles, ruralCircles) {
            const panel = document.getElementById('detailPanel');
            const title = document.getElementById('detailPanelTitle');
            const grid = document.getElementById('detailPanelGrid');
            const chartContainer = document.getElementById('detailPanelChartContainer');
            const zoomView = document.getElementById('zoomView');
            
            // è®¾ç½®æ ‡é¢˜
            title.textContent = `Cell Details`;
            
            // è®¡ç®—å€¼
            const urbanValue = calculateValue(cell, true);
            const ruralValue = calculateValue(cell, false);
            const valueUnit = currentConfig.colorMapping === 'population' ? '' : '/kmÂ²';
            
            // åˆ›å»ºæ”¾å¤§è§†å›¾
            createZoomView(zoomView, cell, circleCount, urbanCircles, ruralCircles);
            
            // å¡«å……è¯¦ç»†ä¿¡æ¯
            grid.innerHTML = `
                <div class="detail-panel-section">
                    <h3>Geographic Information</h3>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Longitude:</span>
                        <span class="detail-panel-value">${cell.longitude.toFixed(4)}Â°</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Latitude:</span>
                        <span class="detail-panel-value">${cell.latitude.toFixed(4)}Â°</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Grid Size:</span>
                        <span class="detail-panel-value">${currentConfig.gridSize}km</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Total Circles:</span>
                        <span class="detail-panel-value">${circleCount}</span>
                    </div>
                </div>
                
                <div class="detail-panel-section">
                    <h3>Population Data</h3>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Total Population:</span>
                        <span class="detail-panel-value">${Math.round(cell.total_population).toLocaleString()}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Urban Population:</span>
                        <span class="detail-panel-value">${Math.round(cell.urban_population).toLocaleString()}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Rural Population:</span>
                        <span class="detail-panel-value">${Math.round(cell.rural_population).toLocaleString()}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Urban Share:</span>
                        <span class="detail-panel-value">${((cell.urban_population / cell.total_population) * 100).toFixed(1)}%</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Urban Density:</span>
                        <span class="detail-panel-value">${cell.urban_area > 0 ? (cell.urban_population / cell.urban_area).toFixed(0) : '0'} /kmÂ²</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Rural Density:</span>
                        <span class="detail-panel-value">${cell.rural_area > 0 ? (cell.rural_population / cell.rural_area).toFixed(0) : '0'} /kmÂ²</span>
                    </div>
                    
                    <div class="detail-panel-chart">
                        <h4>Population Distribution</h4>
                        <div id="detailPanelChartContainer"></div>
                    </div>
                </div>
                
                <div class="detail-panel-section">
                    <h3>Area Information</h3>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Urban Area:</span>
                        <span class="detail-panel-value">${cell.urban_area.toFixed(1)} kmÂ²</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Rural Area:</span>
                        <span class="detail-panel-value">${cell.rural_area.toFixed(1)} kmÂ²</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Total Area:</span>
                        <span class="detail-panel-value">${(cell.urban_area + cell.rural_area).toFixed(1)} kmÂ²</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Urban Area Share:</span>
                        <span class="detail-panel-value">${((cell.urban_area / (cell.urban_area + cell.rural_area)) * 100).toFixed(1)}%</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Urban Circles:</span>
                        <span class="detail-panel-value">${urbanCircles}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Rural Circles:</span>
                        <span class="detail-panel-value">${ruralCircles}</span>
                    </div>
                    
                    <div class="detail-panel-chart">
                        <h4>Area Distribution</h4>
                        <div id="detailPanelAreaChartContainer"></div>
                    </div>
                </div>
                
                <div class="detail-panel-section">
                    <h3>Visualization Settings</h3>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Circle Size:</span>
                        <span class="detail-panel-value">${currentConfig.circleSize}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Circle Spacing:</span>
                        <span class="detail-panel-value">${currentConfig.circleSpacing}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Max Circles:</span>
                        <span class="detail-panel-value">${currentConfig.maxCircles}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Area Data:</span>
                        <span class="detail-panel-value">${currentConfig.useRealArea ? 'Real Area' : 'Fixed Area'}</span>
                    </div>
                </div>
            `;
            
            // åˆ›å»ºäººå£åˆ†å¸ƒå›¾è¡¨
            const colorScale = createColorScale([cell]);
            createDetailChart(document.getElementById('detailPanelChartContainer'), cell, urbanCircles, ruralCircles, colorScale);
            
            // åˆ›å»ºé¢ç§¯åˆ†å¸ƒå›¾è¡¨
            createAreaChart(document.getElementById('detailPanelAreaChartContainer'), cell, colorScale);
            
            // æ˜¾ç¤ºé¢æ¿
            panel.style.display = 'flex';
            setTimeout(() => {
                panel.classList.add('show');
            }, 10);
        }
        
        // åˆ›å»ºè¯¦ç»†ä¿¡æ¯å›¾è¡¨
        function createDetailChart(container, cell, urbanCircles, ruralCircles, colorScale) {
            // æ¸…é™¤ç°æœ‰å†…å®¹
            container.innerHTML = '';
            
            const width = container.clientWidth || 400;
            const height = 200;
            
            const svg = d3.select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // æ•°æ® - ä½¿ç”¨å®é™…äººå£æ•°æ®ï¼Œä¸å—åœ†å½¢è®¾ç½®å½±å“ï¼Œå¹¶å››èˆäº”å…¥ä¸ºæ•´æ•°ï¼Œä½¿ç”¨å½“å‰Cellçš„é¢œè‰²åˆ†é…
            const data = [
                { name: 'Urban', value: Math.round(cell.urban_population), color: colorScale(calculateValue(cell, true)) },
                { name: 'Rural', value: Math.round(cell.rural_population), color: colorScale(calculateValue(cell, false)) }
            ];
            
            // æ¯”ä¾‹å°º
            const x = d3.scaleBand()
                .domain(data.map(d => d.name))
                .range([0, width])
                .padding(0.1);
            
            const y = d3.scaleLinear()
                .domain([0, Math.max(data[0].value, data[1].value)])
                .range([height - 40, 40]);
            
            // ç»˜åˆ¶æŸ±çŠ¶å›¾
            svg.selectAll("rect")
                .data(data)
                .enter()
                .append("rect")
                .attr("x", d => x(d.name))
                .attr("y", d => y(d.value))
                .attr("width", x.bandwidth())
                .attr("height", d => height - 40 - y(d.value))
                .attr("fill", d => d.color)
                .attr("opacity", 0.8);
            
            // æ·»åŠ æ•°å€¼æ ‡ç­¾
            svg.selectAll("text")
                .data(data)
                .enter()
                .append("text")
                .attr("x", d => x(d.name) + x.bandwidth() / 2)
                .attr("y", d => y(d.value) - 5)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("fill", "#333")
                .text(d => `${d.value.toLocaleString()}`);
            
            // æ·»åŠ xè½´æ ‡ç­¾
            svg.selectAll(".x-label")
                .data(data)
                .enter()
                .append("text")
                .attr("class", "x-label")
                .attr("x", d => x(d.name) + x.bandwidth() / 2)
                .attr("y", height - 5)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("fill", "#333")
                .text(d => d.name);
            
            // // æ·»åŠ æ ‡é¢˜
            // svg.append("text")
            //     .attr("x", width / 2)
            //     .attr("y", 20)
            //     .attr("text-anchor", "middle")
            //     .attr("font-size", "14px")
            //     .attr("font-weight", "bold")
            //     .text("Population Distribution");
        }
        
        // åˆ›å»ºé¢ç§¯åˆ†å¸ƒpie chart
        function createAreaChart(container, cell, colorScale) {
            // æ¸…é™¤ç°æœ‰å†…å®¹
            container.innerHTML = '';
            
            const width = container.clientWidth || 400;
            const height = 200;
            
            const svg = d3.select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // æ•°æ® - é¢ç§¯æ•°æ®å››èˆäº”å…¥ä¸ºæ•´æ•°ï¼Œä½¿ç”¨å½“å‰Cellçš„é¢œè‰²åˆ†é…
            const data = [
                { name: 'Urban Area', value: Math.round(cell.urban_area), color: colorScale(calculateValue(cell, true)) },
                { name: 'Rural Area', value: Math.round(cell.rural_area), color: colorScale(calculateValue(cell, false)) }
            ].filter(d => d.value > 0); // åªæ˜¾ç¤ºæœ‰é¢ç§¯çš„åŒºåŸŸ
            
            if (data.length === 0) {
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", height / 2)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .attr("fill", "#666")
                    .text("No area data available");
                return;
            }
            
            // åˆ›å»ºpie chart
            const radius = Math.min(width, height) / 3;
            const centerX = width / 2;
            const centerY = height / 2;
            
            const pie = d3.pie()
                .value(d => d.value)
                .sort(null);
            
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius);
            
            // ç»˜åˆ¶pie slices
            const pieGroup = svg.append("g")
                .attr("transform", `translate(${centerX}, ${centerY})`);
            
            pieGroup.selectAll("path")
                .data(pie(data))
                .enter()
                .append("path")
                .attr("d", arc)
                .attr("fill", d => d.data.color)
                .attr("opacity", 0.8)
                .attr("stroke", "#fff")
                .attr("stroke-width", 2);
            
            // æ·»åŠ æ ‡ç­¾
            pieGroup.selectAll("text")
                .data(pie(data))
                .enter()
                .append("text")
                .attr("transform", d => `translate(${arc.centroid(d)})`)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("fill", "#fff")
                .attr("font-weight", "bold")
                .text(d => `${((d.data.value / (Math.round(cell.urban_area) + Math.round(cell.rural_area))) * 100).toFixed(1)}%`);
            
            // æ·»åŠ å›¾ä¾‹
            const legend = svg.append("g")
                .attr("transform", `translate(${width - 100}, 20)`);
            
            data.forEach((d, i) => {
                const legendItem = legend.append("g")
                    .attr("transform", `translate(0, ${i * 20})`);
                
                legendItem.append("rect")
                    .attr("width", 12)
                    .attr("height", 12)
                    .attr("fill", d.color);
                
                legendItem.append("text")
                    .attr("x", 18)
                    .attr("y", 9)
                    .attr("font-size", "11px")
                    .text(d.name);
            });
        }
        
        // å…³é—­è¯¦ç»†ä¿¡æ¯é¢æ¿
        function closeDetailPanel() {
            const panel = document.getElementById('detailPanel');
            
            // æ¸…é™¤é€‰ä¸­çŠ¶æ€
            d3.selectAll(".cell-clickable").classed("selected", false);
            
            panel.classList.remove('show');
            setTimeout(() => {
                panel.style.display = 'none';
            }, 300);
        }
        
        // åˆå§‹åŒ–å›¾è¡¨
        function initChart() {
            const { width, height, areaSize } = getResponsiveDimensions();
            
            // ä½¿ç”¨currentConfigä¸­çš„maxCircles
            MAPPING_CONFIG.maxCircles = currentConfig.maxCircles;
            
            // æ¸…é™¤ç°æœ‰å†…å®¹ï¼Œä½†ä¿ç•™ç¼©æ”¾æ§åˆ¶æŒ‰é’®
            const zoomControls = document.querySelector('.zoom-controls');
            
            // ä¿å­˜ç¼©æ”¾æŒ‰é’®çš„HTMLå†…å®¹
            const zoomControlsHTML = zoomControls ? zoomControls.innerHTML : '';
            
            d3.select("#chart").selectAll("*").remove();
            
            // é‡æ–°åˆ›å»ºç¼©æ”¾æ§åˆ¶æŒ‰é’®
            if (zoomControlsHTML) {
                const newZoomControls = document.createElement('div');
                newZoomControls.className = 'zoom-controls';
                newZoomControls.innerHTML = zoomControlsHTML;
                document.getElementById('chart').appendChild(newZoomControls);
            }

            const svg = d3.select("#chart")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");

            // åˆ›å»ºç¼©æ”¾è¡Œä¸º
            const zoom = d3.zoom()
                .scaleExtent([MIN_ZOOM, MAX_ZOOM])
                .on("zoom", function(event) {
                    currentZoom = event.transform;
                    zoomLevel = event.transform.k;
                    
                    // åº”ç”¨ç¼©æ”¾å˜æ¢åˆ°åœ°å›¾ç»„
                    svg.select(".map-group").attr("transform", event.transform);
                    
                    // å»¶è¿Ÿæ›´æ–°ç¼©æ”¾ä¿¡æ¯ï¼Œé¿å…åœ¨åˆå§‹åŒ–æ—¶å‡ºé”™
                    setTimeout(() => {
                        updateZoomInfo();
                    }, 0);
                })
                .on("end", function(event) {
                    // åŒå‡»æ”¾å¤§åŠŸèƒ½ä¿ç•™ï¼Œä½†ä¸é‡ç½®åˆ°åˆå§‹ä½ç½®
                    if (event.sourceEvent && event.sourceEvent.type === "dblclick") {
                        // åŒå‡»æ—¶æ”¾å¤§ï¼Œè€Œä¸æ˜¯é‡ç½®
                        const currentTransform = d3.zoomTransform(svg.node());
                        const newScale = Math.min(MAX_ZOOM, currentTransform.k * 1.5);
                        
                        if (newScale > currentTransform.k) {
                            // è·å–åŒå‡»ä½ç½®ç›¸å¯¹äºSVGçš„åæ ‡
                            const rect = svg.node().getBoundingClientRect();
                            const x = event.sourceEvent.clientX - rect.left;
                            const y = event.sourceEvent.clientY - rect.top;
                            
                            // ä½¿ç”¨D3.jsçš„zoom.scaleToæ–¹æ³•ï¼Œä»¥åŒå‡»ä½ç½®ä¸ºä¸­å¿ƒè¿›è¡Œå¹³æ»‘æ”¾å¤§
                            const point = [x, y];
                            svg.call(zoom.scaleTo, newScale, point);
                            
                            // æ›´æ–°å…¨å±€zoomçŠ¶æ€
                            currentZoom = d3.zoomTransform(svg.node());
                            zoomLevel = newScale;
                            updateZoomInfo();
                        }
                    }
                });

            // åº”ç”¨ç¼©æ”¾è¡Œä¸ºåˆ°SVG
            svg.call(zoom);

            const tooltip = d3.select(".chart-container")
                .append("div")
                .attr("class", "tooltip");

            // å“åº”å¼æŠ•å½±
            const projection = d3.geoMercator()
                .center([10, -15])
                .scale(Math.min(width, height) / 1.5)
                .translate([width / 2, height / 2]);

            const path = d3.geoPath().projection(projection);

            // åˆ›å»ºåœ°å›¾ç»„
            const mapGroup = svg.append("g")
                .attr("class", "map-group");

            // åŠ è½½æ•°æ®
            const dataFile = currentConfig.gridSize === '100' 
                ? "aggregated_100km_africa.json" 
                : "aggregated_1000km_africa.json";

            Promise.all([
                d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"),
                d3.json(dataFile)
            ]).then(([geojson, data]) => {
                const gridData = Object.values(data.grid_data)
                    .map(d => {
                        const rawLon = d.geographic_location.longitude;
                        const rawLat = d.geographic_location.latitude;
                        const correctedLon = -rawLat;
                        const correctedLat = -rawLon;

                        return {
                            ...d,
                            total_population: d.rural_population + d.urban_population,
                            longitude: correctedLon,
                            latitude: correctedLat
                        };
                    })
                    // ç§»é™¤è¿‡æ»¤æ¡ä»¶ï¼Œæ˜¾ç¤ºæ‰€æœ‰ç½‘æ ¼ï¼ˆåŒ…æ‹¬äººå£ä¸º0çš„ç½‘æ ¼ï¼‰
                    // .filter(d => d.total_population > 0);

                // ä¿å­˜åˆ°å…¨å±€å˜é‡
                window.gridData = gridData;

                // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
                const populations = gridData.map(d => d.total_population);
                const minPop = Math.min(...populations);
                const maxPop = Math.max(...populations);

                // èƒŒæ™¯åœ°å›¾
                mapGroup.append("g")
                    .selectAll("path")
                    .data(geojson.features.filter(d => d.properties.continent === "Africa"))
                    .enter()
                    .append("path")
                    .attr("d", path)
                    .attr("fill", "#f0f0f0")
                    .attr("stroke", "#999")
                    .attr("stroke-width", Math.max(0.3, width / 1000));

                // åˆ›å»ºé¢œè‰²æ¯”ä¾‹å°º
                const colorScale = createColorScale(gridData);
                
                // æ ¹æ®å¯è§†åŒ–æ¨¡å¼é€‰æ‹©ç»˜åˆ¶æ–¹æ³•
                if (currentConfig.visualizationMode === 'concentric') {
                    // ä½¿ç”¨åŒå¿ƒåœ†æ¨¡å¼
                    createConcentricCircles(svg, gridData, colorScale, areaSize);
                    
                    // åˆ›å»ºå›¾ä¾‹
                    const maxValue = Math.max(...gridData.map(d => Math.max(calculateValue(d, true), calculateValue(d, false))));
                    createLegend(svg, colorScale, maxValue);
                } else if (currentConfig.visualizationMode === 'rect') {
                    // ä½¿ç”¨çŸ©å½¢æ¨¡å¼
                    createRectangles(svg, gridData, colorScale, areaSize);
                    
                    // åˆ›å»ºå›¾ä¾‹
                    const maxValue = Math.max(...gridData.map(d => Math.max(calculateValue(d, true), calculateValue(d, false))));
                    createLegend(svg, colorScale, maxValue);
                } else {
                    // ä½¿ç”¨æ•£ç‚¹å›¾æ¨¡å¼ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
                    gridData.forEach(cell => {
                    const projectedPos = projection([cell.longitude, cell.latitude]);
                    if (!projectedPos) return;

                    const circleCount = calculateCircleCount(cell.total_population, minPop, maxPop);
                    const positions = generateCirclePositionsInFixedArea(circleCount, projectedPos[0], projectedPos[1], areaSize);

                    // è®¡ç®—åŸä¹¡åœ†å½¢æ•°é‡
                    let urbanCircles, ruralCircles;
                    
                    if (currentConfig.useRealArea) {
                        const cellTotalArea = cell.rural_area + cell.urban_area;
                        if (cellTotalArea > 0) {
                            const urbanRatio = cell.urban_area / cellTotalArea;
                            const ruralRatio = cell.rural_area / cellTotalArea;
                            urbanCircles = Math.round(circleCount * urbanRatio);
                            ruralCircles = circleCount - urbanCircles;
                        } else {
                            // ä½¿ç”¨å›ºå®šé¢ç§¯æ¨¡å¼ï¼šå†…åœ†å æ®20%çš„æ•°é‡
                            urbanCircles = Math.round(circleCount * MAPPING_CONFIG.urbanAreaShare);
                            ruralCircles = circleCount - urbanCircles;
                        }
                    } else {
                        urbanCircles = Math.round(circleCount * MAPPING_CONFIG.urbanAreaShare);
                        ruralCircles = circleCount - urbanCircles;
                    }

                    // åˆ›å»ºç½‘æ ¼å•å…ƒç»„
                    const cellGroup = svg.select(".map-group").append("g")
                        .attr("class", "cell-clickable")
                        .attr("data-cell-id", `${cell.longitude}-${cell.latitude}`)
                        .datum({ urbanCircles: urbanCircles, ruralCircles: ruralCircles })
                        .on("click", function(event) {
                            // ç§»é™¤ä¹‹å‰é€‰ä¸­çš„cellçš„é«˜äº®
                            d3.selectAll(".cell-clickable").classed("selected", false);
                            
                            // ä¸ºå½“å‰cellæ·»åŠ é€‰ä¸­çŠ¶æ€
                            d3.select(this).classed("selected", true);
                            
                            // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
                            showDetailPanel(cell, circleCount, urbanCircles, ruralCircles);
                        });

                    // æ·»åŠ é€æ˜ç‚¹å‡»åŒºåŸŸ
                    const clickSize = areaSize * 1.5; // æ›´å¤§çš„ç‚¹å‡»åŒºåŸŸ
                    cellGroup.append("rect")
                        .attr("x", projectedPos[0] - clickSize/2)
                        .attr("y", projectedPos[1] - clickSize/2)
                        .attr("width", clickSize)
                        .attr("height", clickSize)
                        .attr("fill", "transparent")
                        .style("pointer-events", "all");

                    // ç»˜åˆ¶åœ†å½¢
                    positions.forEach((pos, index) => {
                        const isUrban = pos.spiralIndex < urbanCircles;
                        const value = calculateValue(cell, isUrban);
                        const safeValue = isFinite(value) && value >= 0 ? value : 0;
                        
                        cellGroup.append("circle")
                            .attr("cx", pos.x)
                            .attr("cy", pos.y)
                            .attr("r", pos.radius)
                            .attr("fill", colorScale(safeValue))
                            .attr("opacity", 0.8)
                            .on("mouseover", function(event) {
                                const urbanValue = calculateValue(cell, true);
                                const ruralValue = calculateValue(cell, false);
                                const valueUnit = currentConfig.colorMapping === 'population' ? '' : '/kmÂ²';
                                
                                tooltip.transition()
                                    .duration(200)
                                    .style("opacity", .9);
                                tooltip.html(`
                                    <strong>Cell Info:</strong><br>
                                    <strong>Lon:</strong> ${cell.longitude.toFixed(2)}Â°, 
                                    <strong>Lat:</strong> ${cell.latitude.toFixed(2)}Â°<br>
                                    <strong>Total Population:</strong> ${Math.round(cell.total_population).toLocaleString()}<br>
                                    <strong>Circles:</strong> ${circleCount} (${urbanCircles} urban, ${ruralCircles} rural)<br>
                                    <strong>Urban:</strong> ${Math.round(cell.urban_population).toLocaleString()} (${urbanValue.toFixed(1)}${valueUnit})<br>
                                    <strong>Rural:</strong> ${Math.round(cell.rural_population).toLocaleString()} (${ruralValue.toFixed(1)}${valueUnit})<br>
                                    <strong>Urban Area:</strong> ${cell.urban_area.toFixed(1)} kmÂ²<br>
                                    <strong>Rural Area:</strong> ${cell.rural_area.toFixed(1)} kmÂ²
                                `)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 28) + "px");
                            })
                            .on("mouseout", () => {
                                tooltip.transition()
                                    .duration(500)
                                    .style("opacity", 0);
                            });
                    });
                });
                }

                // åˆ›å»ºå›¾ä¾‹
                const maxValue = Math.max(...gridData.map(d => Math.max(calculateValue(d, true), calculateValue(d, false))));
                
                createLegend(svg, colorScale, maxValue);
                
                // æ›´æ–°å›¾ä¾‹ä¸­çš„è¿ç»­é¢œè‰²æ»‘åŠ¨æ¡
                updateLegendFigure();
                
                // é‡æ–°ç»‘å®šzoomæŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
                const resetZoomBtn = document.getElementById('resetZoomBtn');
                
                // å…ˆç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…é‡å¤ç»‘å®š
                if (resetZoomBtn) {
                    resetZoomBtn.removeEventListener('click', resetZoom);
                    resetZoomBtn.addEventListener('click', resetZoom);
                }
                
                // æ›´æ–°ç¼©æ”¾ä¿¡æ¯
                updateZoomInfo();
            });
        }
        
        // åˆ›å»ºåŒå¿ƒåœ†å¯è§†åŒ–
        function createConcentricCircles(svg, gridData, colorScale, areaSize) {
            // æ¸…é™¤ç°æœ‰å†…å®¹
            svg.select(".map-group").selectAll(".cell-clickable").remove();
            
            const tooltip = d3.select(".chart-container .tooltip");
            
            // å“åº”å¼æŠ•å½±
            const width = svg.attr("width");
            const height = svg.attr("height");
            const projection = d3.geoMercator()
                .center([10, -15])
                .scale(Math.min(width, height) / 1.5)
                .translate([width / 2, height / 2]);

            // ä¸ºæ¯ä¸ªç½‘æ ¼åˆ›å»ºåŒå¿ƒåœ†
            gridData.forEach(cell => {
                const projectedPos = projection([cell.longitude, cell.latitude]);
                if (!projectedPos) return;

                // è®¡ç®—åœ†å½¢å¤§å°ï¼ˆåŸºäºæ€»äººå£ï¼‰
                const populations = gridData.map(d => d.total_population);
                const minPop = Math.min(...populations);
                const maxPop = Math.max(...populations);
                const circleCount = calculateCircleCount(cell.total_population, minPop, maxPop);
                
                // è®¡ç®—åŒå¿ƒåœ†çš„å¤§å°
                // const radius = currentConfig.gridSize === '100' ? areaSize * 0.2 : areaSize * 0.5;
                const radius = currentConfig.gridSize === '100' ? (areaSize / currentConfig.gridSize) * currentConfig.circleSize * 100 : (areaSize / currentConfig.gridSize) * currentConfig.circleSize * 1000;
                
                // è®¡ç®—urban areaå æ¯”ï¼ˆç”¨äºå†…åœ†å¤§å°ï¼‰
                const totalArea = cell.urban_area + cell.rural_area;
                let urbanAreaRatio;
                if (currentConfig.useRealArea) {
                    // ä½¿ç”¨çœŸå®é¢ç§¯æ¯”ä¾‹
                    urbanAreaRatio = totalArea > 0 ? cell.urban_area / totalArea : 0;
                } else {
                    // ä½¿ç”¨å›ºå®šé¢ç§¯æ¨¡å¼ï¼šå†…åœ†å æ®20%çš„é¢ç§¯
                    urbanAreaRatio = 0.2;
                }
                const innerRadius = radius * Math.sqrt(urbanAreaRatio); // å†…åœ†åŠå¾„
                
                // åˆ›å»ºç½‘æ ¼å•å…ƒç»„
                const cellGroup = svg.select(".map-group").append("g")
                    .attr("class", "cell-clickable")
                    .attr("data-cell-id", `${cell.longitude}-${cell.latitude}`)
                    .datum({ urbanAreaRatio: urbanAreaRatio, totalPopulation: cell.total_population })
                    .on("click", function(event) {
                        // ç§»é™¤ä¹‹å‰é€‰ä¸­çš„cellçš„é«˜äº®
                        d3.selectAll(".cell-clickable").classed("selected", false);
                        
                        // ä¸ºå½“å‰cellæ·»åŠ é€‰ä¸­çŠ¶æ€
                        d3.select(this).classed("selected", true);
                        
                        // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
                        showDetailPanel(cell, 1, 1, 0); // ç®€åŒ–å‚æ•°
                    });

                // æ·»åŠ é€æ˜ç‚¹å‡»åŒºåŸŸ
                const clickSize = radius * 2;
                cellGroup.append("rect")
                    .attr("x", projectedPos[0] - clickSize/2)
                    .attr("y", projectedPos[1] - clickSize/2)
                    .attr("width", clickSize)
                    .attr("height", clickSize)
                    .attr("fill", "transparent")
                    .style("pointer-events", "all");

                // ç»˜åˆ¶å¤–åœ†ï¼ˆä»£è¡¨ruraläººå£ï¼‰
                const ruralValue = calculateValue(cell, false); // ä½¿ç”¨ruralå€¼ä½œä¸ºå¤–åœ†é¢œè‰²
                const safeRuralValue = isFinite(ruralValue) && ruralValue >= 0 ? ruralValue : 0;
                
                cellGroup.append("circle")
                    .attr("cx", projectedPos[0])
                    .attr("cy", projectedPos[1])
                    .attr("r", radius)
                    .attr("fill", colorScale(safeRuralValue))
                    .attr("opacity", 0.8)
                    .on("mouseover", function(event) {
                        const urbanValue = calculateValue(cell, true);
                        const ruralValue = calculateValue(cell, false);
                        const valueUnit = currentConfig.colorMapping === 'population' ? '' : '/kmÂ²';
                        
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        tooltip.html(`
                            <strong>Cell Info:</strong><br>
                            <strong>Lon:</strong> ${cell.longitude.toFixed(2)}Â°, 
                            <strong>Lat:</strong> ${cell.latitude.toFixed(2)}Â°<br>
                            <strong>Total Population:</strong> ${Math.round(cell.total_population).toLocaleString()}<br>
                            <strong>Rural Population:</strong> ${Math.round(cell.rural_population).toLocaleString()} (å¤–åœ†)<br>
                            <strong>Urban Population:</strong> ${Math.round(cell.urban_population).toLocaleString()} (å†…åœ†, ${urbanAreaRatio.toFixed(1)}% area)<br>
                            <strong>Rural Value:</strong> ${ruralValue.toFixed(1)}${valueUnit}<br>
                            <strong>Urban Value:</strong> ${urbanValue.toFixed(1)}${valueUnit}<br>
                            <strong>Rural Area:</strong> ${cell.rural_area.toFixed(1)} kmÂ²<br>
                            <strong>Urban Area:</strong> ${cell.urban_area.toFixed(1)} kmÂ²
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", () => {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                // ç»˜åˆ¶å†…åœ†ï¼ˆä»£è¡¨urbanäººå£ï¼‰
                if (urbanAreaRatio > 0) {
                    const urbanValue = calculateValue(cell, true); // ä½¿ç”¨urbanå€¼ä½œä¸ºå†…åœ†é¢œè‰²
                    const safeUrbanValue = isFinite(urbanValue) && urbanValue >= 0 ? urbanValue : 0;
                    
                    cellGroup.append("circle")
                        .attr("cx", projectedPos[0])
                        .attr("cy", projectedPos[1])
                        .attr("r", innerRadius)
                        .attr("fill", colorScale(safeUrbanValue))
                        .attr("opacity", 0.9)
                        .on("mouseover", function(event) {
                            const urbanValue = calculateValue(cell, true);
                            const ruralValue = calculateValue(cell, false);
                            const valueUnit = currentConfig.colorMapping === 'population' ? '' : '/kmÂ²';
                            
                            tooltip.transition()
                                .duration(200)
                                .style("opacity", .9);
                            tooltip.html(`
                                <strong>Cell Info:</strong><br>
                                <strong>Lon:</strong> ${cell.longitude.toFixed(2)}Â°, 
                                <strong>Lat:</strong> ${cell.latitude.toFixed(2)}Â°<br>
                                <strong>Total Population:</strong> ${cell.total_population.toLocaleString()}<br>
                                <strong>Rural Population:</strong> ${cell.rural_population.toLocaleString()} (å¤–åœ†)<br>
                                <strong>Urban Population:</strong> ${cell.urban_population.toLocaleString()} (å†…åœ†, ${urbanAreaRatio.toFixed(1)}% area)<br>
                                <strong>Rural Value:</strong> ${ruralValue.toFixed(1)}${valueUnit}<br>
                                <strong>Urban Value:</strong> ${urbanValue.toFixed(1)}${valueUnit}<br>
                                <strong>Rural Area:</strong> ${cell.rural_area.toFixed(1)} kmÂ²<br>
                                <strong>Urban Area:</strong> ${cell.urban_area.toFixed(1)} kmÂ²
                            `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", () => {
                            tooltip.transition()
                                .duration(500)
                                .style("opacity", 0);
                        });
                }
            });
            
            // é‡æ–°ç»‘å®šzoomæŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            const resetZoomBtn = document.getElementById('resetZoomBtn');
            
            // å…ˆç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…é‡å¤ç»‘å®š
            if (resetZoomBtn) {
                resetZoomBtn.removeEventListener('click', resetZoom);
                resetZoomBtn.addEventListener('click', resetZoom);
            }
            
            // æ›´æ–°ç¼©æ”¾ä¿¡æ¯
            updateZoomInfo();
        }

        // äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('gridSize').addEventListener('change', function() {
            currentConfig.gridSize = this.value;
            
            // æ›´æ–°è‡ªå®šä¹‰é¢œè‰²è®¾ç½®çš„é˜ˆå€¼
            if (this.value === '100') {
                customColorSettings.population.thresholds = [1000, 5000, 15000, 50000, 100000, 300000];
            } else {
                customColorSettings.population.thresholds = [100000, 500000, 1500000, 5000000, 10000000, 30000000];
            }
            
            // æ ¹æ®ç½‘æ ¼å¤§å°è‡ªåŠ¨è°ƒæ•´åœ†å½¢å‚æ•°
            if (this.value === '100') {
                // 100kmå‚æ•°
                currentConfig.circleSize = 0.2;
                currentConfig.circleSpacing = 0.4;
                currentConfig.maxCircles = 16;
                document.getElementById('circleSize').value = 0.2;
                document.getElementById('circleSpacing').value = 0.4;
                document.getElementById('maxCircles').value = 16;
                document.getElementById('circleSizeValue').textContent = '0.2';
                document.getElementById('circleSpacingValue').textContent = '0.4';
                document.getElementById('maxCirclesValue').textContent = '16';
            } else {
                // 1000kmå‚æ•°
                currentConfig.circleSize = 0.5;
                currentConfig.circleSpacing = 1.0;
                currentConfig.maxCircles = 100;
                document.getElementById('circleSize').value = 0.5;
                document.getElementById('circleSpacing').value = 1.0;
                document.getElementById('maxCircles').value = 100;
                document.getElementById('circleSizeValue').textContent = '0.5';
                document.getElementById('circleSpacingValue').textContent = '1.0';
                document.getElementById('maxCirclesValue').textContent = '100';
            }
            
            updateLegendFigure();
            initChart();
        });

        document.getElementById('areaData').addEventListener('change', function() {
            currentConfig.useRealArea = this.value === 'true';
            initChart();
        });

        document.getElementById('colorMapping').addEventListener('change', function() {
            currentConfig.colorMapping = this.value;
            initChart();
        });

        document.getElementById('circleSize').addEventListener('input', function() {
            currentConfig.circleSize = parseFloat(this.value);
            document.getElementById('circleSizeValue').textContent = this.value;
            initChart();
        });

        document.getElementById('circleSpacing').addEventListener('input', function() {
            currentConfig.circleSpacing = parseFloat(this.value);
            document.getElementById('circleSpacingValue').textContent = this.value;
            initChart();
        });

        document.getElementById('maxCircles').addEventListener('input', function() {
            currentConfig.maxCircles = parseInt(this.value);
            document.getElementById('maxCirclesValue').textContent = this.value;
            initChart();
        });

        document.getElementById('visualizationMode').addEventListener('change', function() {
            currentConfig.visualizationMode = this.value;
            updateLegendFigure();
            initChart();
        });

        // å…³é—­æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('closeDetailPanelBtn').addEventListener('click', closeDetailPanel);
        
        // ESCé”®å…³é—­é¢æ¿
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeDetailPanel();
            }
        });

        // æ›´æ–°å›¾ä¾‹ä¸­çš„å¯è§†åŒ–æ¨¡å¼å›¾ä¾‹
        function updateLegendFigure() {
            const figureContainer = d3.select('.figure-container');
            if (figureContainer.empty()) return;
            
            // æ¸…é™¤ç°æœ‰å†…å®¹
            figureContainer.selectAll('*').remove();
            
            // æ ¹æ®å½“å‰é…ç½®é€‰æ‹©å¯¹åº”çš„å›¾ä¾‹
            const getFigurePath = () => {
                const mode = currentConfig.visualizationMode;
                const size = currentConfig.gridSize;
                
                if (mode === 'scatter') {
                    return size === '100' ? 'figures/scatter_100.svg' : 'figures/scatter_1000.svg';
                } else if (mode === 'concentric') {
                    return size === '100' ? 'figures/concentric_100.svg' : 'figures/concentric_1000.svg';
                } else if (mode === 'rect') {
                    return size === '100' ? 'figures/rect_100.svg' : 'figures/rect_1000.svg';
                }
                return 'figures/scatter_100.svg'; // é»˜è®¤
            };

            // åˆ›å»ºå›¾ä¾‹å®¹å™¨
            const legendFigure = figureContainer.append("foreignObject")
                .attr("x", -20)
                .attr("y", 0)
                .attr("width", 400)
                .attr("height", 150);

            // åŠ è½½SVGå›¾ä¾‹
            const figurePath = getFigurePath();
            fetch(figurePath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(svgContent => {
                    // åˆ›å»ºä¸´æ—¶divæ¥è§£æSVG
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = svgContent;
                    const svgElement = tempDiv.querySelector('svg');
                    
                    if (svgElement) {
                        // è°ƒæ•´SVGå¤§å°å’Œæ ·å¼
                        svgElement.style.width = '100%';
                        svgElement.style.height = 'auto';
                        svgElement.style.maxHeight = '120px';
                        
                        // å°†SVGå†…å®¹æ’å…¥åˆ°foreignObjectä¸­
                        legendFigure.node().appendChild(svgElement);
                    } else {
                        throw new Error('SVG element not found in response');
                    }
                })
                .catch(error => {
                    console.error('Error loading figure:', error);
                    // å¦‚æœåŠ è½½å¤±è´¥ï¼Œæ˜¾ç¤ºå¤‡ç”¨æ–‡æœ¬
                    figureContainer.append("text")
                        .attr("x", 0)
                        .attr("y", 35)
                        .attr("font-size", "9px")
                        .attr("fill", "#666")
                        .text("â€¢ Visualization mode: " + currentConfig.visualizationMode);
                });
            
            // åªä¿ç•™ç«–ç€çš„æ»‘åŠ¨æ¡ï¼Œåˆ é™¤æ¨ªç€çš„æ»‘åŠ¨æ¡
        }

        // åˆ›å»ºçŸ©å½¢å¯è§†åŒ–
        function createRectangles(svg, gridData, colorScale, areaSize) {
            // æ¸…é™¤ç°æœ‰å†…å®¹
            svg.select(".map-group").selectAll(".cell-clickable").remove();
            
            const tooltip = d3.select(".chart-container .tooltip");
            
            // å“åº”å¼æŠ•å½±
            const width = svg.attr("width");
            const height = svg.attr("height");
            const projection = d3.geoMercator()
                .center([10, -15])
                .scale(Math.min(width, height) / 1.5)
                .translate([width / 2, height / 2]);

            // ä¸ºæ¯ä¸ªç½‘æ ¼åˆ›å»ºçŸ©å½¢
            gridData.forEach(cell => {
                const projectedPos = projection([cell.longitude, cell.latitude]);
                if (!projectedPos) return;

                // è®¡ç®—çŸ©å½¢å¤§å°ï¼ˆåŸºäºæ€»äººå£ï¼‰
                const populations = gridData.map(d => d.total_population);
                const minPop = Math.min(...populations);
                const maxPop = Math.max(...populations);
                const circleCount = calculateCircleCount(cell.total_population, minPop, maxPop);
                
                // è®¡ç®—çŸ©å½¢çš„å¤§å°
                const rectSize = currentConfig.gridSize === '100' ? 
                    (areaSize / currentConfig.gridSize) * currentConfig.circleSize * 100 * 2 : 
                    (areaSize / currentConfig.gridSize) * currentConfig.circleSize * 1000 * 2;
                
                // è®¡ç®—urban areaå æ¯”ï¼ˆç”¨äºå†…çŸ©å½¢å¤§å°ï¼‰
                const totalArea = cell.urban_area + cell.rural_area;
                let urbanAreaRatio;
                if (currentConfig.useRealArea) {
                    // ä½¿ç”¨çœŸå®é¢ç§¯æ¯”ä¾‹
                    urbanAreaRatio = totalArea > 0 ? cell.urban_area / totalArea : 0;
                } else {
                    // ä½¿ç”¨å›ºå®šé¢ç§¯æ¨¡å¼ï¼šå†…çŸ©å½¢å æ®20%çš„é¢ç§¯
                    urbanAreaRatio = 0.2;
                }
                const innerRectSize = rectSize * Math.sqrt(urbanAreaRatio); // å†…çŸ©å½¢å¤§å°
                
                // åˆ›å»ºç½‘æ ¼å•å…ƒç»„
                const cellGroup = svg.select(".map-group").append("g")
                    .attr("class", "cell-clickable")
                    .attr("data-cell-id", `${cell.longitude}-${cell.latitude}`)
                    .datum({ urbanAreaRatio: urbanAreaRatio, totalPopulation: cell.total_population })
                    .on("click", function(event) {
                        // ç§»é™¤ä¹‹å‰é€‰ä¸­çš„cellçš„é«˜äº®
                        d3.selectAll(".cell-clickable").classed("selected", false);
                        
                        // ä¸ºå½“å‰cellæ·»åŠ é€‰ä¸­çŠ¶æ€
                        d3.select(this).classed("selected", true);
                        
                        // æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
                        showDetailPanel(cell, 1, 1, 0); // ç®€åŒ–å‚æ•°
                    });

                // æ·»åŠ é€æ˜ç‚¹å‡»åŒºåŸŸ
                const clickSize = rectSize * 2;
                cellGroup.append("rect")
                    .attr("x", projectedPos[0] - clickSize/2)
                    .attr("y", projectedPos[1] - clickSize/2)
                    .attr("width", clickSize)
                    .attr("height", clickSize)
                    .attr("fill", "transparent")
                    .style("pointer-events", "all");

                // ç»˜åˆ¶å¤–çŸ©å½¢ï¼ˆä»£è¡¨ruraläººå£ï¼‰
                const ruralValue = calculateValue(cell, false); // ä½¿ç”¨ruralå€¼ä½œä¸ºå¤–çŸ©å½¢é¢œè‰²
                const safeRuralValue = isFinite(ruralValue) && ruralValue >= 0 ? ruralValue : 0;
                
                cellGroup.append("rect")
                    .attr("x", projectedPos[0] - rectSize/2)
                    .attr("y", projectedPos[1] - rectSize/2)
                    .attr("width", rectSize)
                    .attr("height", rectSize)
                    .attr("fill", colorScale(safeRuralValue))
                    .attr("opacity", 0.8)
                    .on("mouseover", function(event) {
                        const urbanValue = calculateValue(cell, true);
                        const ruralValue = calculateValue(cell, false);
                        const valueUnit = currentConfig.colorMapping === 'population' ? '' : '/kmÂ²';
                        
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        tooltip.html(`                            <strong>Cell Info:</strong><br>
                            <strong>Lon:</strong> ${cell.longitude.toFixed(2)}Â°, 
                            <strong>Lat:</strong> ${cell.latitude.toFixed(2)}Â°<br>
                            <strong>Total Population:</strong> ${Math.round(cell.total_population).toLocaleString()}<br>
                            <strong>Rural Population:</strong> ${Math.round(cell.rural_population).toLocaleString()} (å¤–çŸ©å½¢)<br>
                            <strong>Urban Population:</strong> ${Math.round(cell.urban_population).toLocaleString()} (å†…çŸ©å½¢, ${urbanAreaRatio.toFixed(1)}% area)<br>
                            <strong>Rural Value:</strong> ${ruralValue.toFixed(1)}${valueUnit}<br>
                            <strong>Urban Value:</strong> ${urbanValue.toFixed(1)}${valueUnit}<br>
                            <strong>Rural Area:</strong> ${cell.rural_area.toFixed(1)} kmÂ²<br>
                            <strong>Urban Area:</strong> ${cell.urban_area.toFixed(1)} kmÂ²
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", () => {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                // ç»˜åˆ¶å†…çŸ©å½¢ï¼ˆä»£è¡¨urbanäººå£ï¼‰
                if (urbanAreaRatio > 0) {
                    const urbanValue = calculateValue(cell, true); // ä½¿ç”¨urbanå€¼ä½œä¸ºå†…çŸ©å½¢é¢œè‰²
                    const safeUrbanValue = isFinite(urbanValue) && urbanValue >= 0 ? urbanValue : 0;
                    
                    cellGroup.append("rect")
                        .attr("x", projectedPos[0] - innerRectSize/2)
                        .attr("y", projectedPos[1] - innerRectSize/2)
                        .attr("width", innerRectSize)
                        .attr("height", innerRectSize)
                        .attr("fill", colorScale(safeUrbanValue))
                        .attr("opacity", 0.9)
                        .on("mouseover", function(event) {
                            const urbanValue = calculateValue(cell, true);
                            const ruralValue = calculateValue(cell, false);
                            const valueUnit = currentConfig.colorMapping === 'population' ? '' : '/kmÂ²';
                            
                            tooltip.transition()
                                .duration(200)
                                .style("opacity", .9);
                            tooltip.html(`
                                <strong>Cell Info:</strong><br>
                                <strong>Lon:</strong> ${cell.longitude.toFixed(2)}Â°, 
                                <strong>Lat:</strong> ${cell.latitude.toFixed(2)}Â°<br>
                                <strong>Total Population:</strong> ${Math.round(cell.total_population).toLocaleString()}<br>
                                <strong>Rural Population:</strong> ${Math.round(cell.rural_population).toLocaleString()} (å¤–çŸ©å½¢)<br>
                                <strong>Urban Population:</strong> ${Math.round(cell.urban_population).toLocaleString()} (å†…çŸ©å½¢, ${urbanAreaRatio.toFixed(1)}% area)<br>
                                <strong>Rural Value:</strong> ${ruralValue.toFixed(1)}${valueUnit}<br>
                                <strong>Urban Value:</strong> ${urbanValue.toFixed(1)}${valueUnit}<br>
                                <strong>Rural Area:</strong> ${cell.rural_area.toFixed(1)} kmÂ²<br>
                                <strong>Urban Area:</strong> ${cell.urban_area.toFixed(1)} kmÂ²
                            `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", () => {
                            tooltip.transition()
                                .duration(500)
                                .style("opacity", 0);
                        });
                }
            });
            
            // é‡æ–°ç»‘å®šzoomæŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            const resetZoomBtn = document.getElementById('resetZoomBtn');
            
            // å…ˆç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…é‡å¤ç»‘å®š
            if (resetZoomBtn) {
                resetZoomBtn.removeEventListener('click', resetZoom);
                resetZoomBtn.addEventListener('click', resetZoom);
            }
            
            // æ›´æ–°ç¼©æ”¾ä¿¡æ¯
            updateZoomInfo();
        }

        // ç¼©æ”¾æ§åˆ¶å‡½æ•°
        function updateZoomInfo() {
            // ç”±äºåˆ é™¤äº†zoom-infoå’ŒzoomæŒ‰é’®ï¼Œè¿™ä¸ªå‡½æ•°ç°åœ¨ä¸»è¦ç”¨äºæ›´æ–°å…¨å±€çŠ¶æ€
            // å¯ä»¥ä¿ç•™ç”¨äºå°†æ¥çš„æ‰©å±•
        }
        
        function zoomIn() {
            if (zoomLevel < MAX_ZOOM) {
                const svg = d3.select("#chart svg");
                if (!svg.empty()) {
                    // è·å–SVGçš„å°ºå¯¸å’Œå½“å‰zoomçŠ¶æ€
                    const width = parseInt(svg.attr("width"));
                    const height = parseInt(svg.attr("height"));
                    const currentTransform = d3.zoomTransform(svg.node());
                    
                    // è®¡ç®—æ–°çš„ç¼©æ”¾æ¯”ä¾‹
                    const newScale = Math.min(MAX_ZOOM, currentTransform.k * 1.5);
                    
                    // ä»¥åœ°å›¾ä¸­å¿ƒä¸ºç¼©æ”¾ä¸­å¿ƒ
                    const centerX = width / 2;
                    const centerY = height / 2;
                    
                    // åˆ›å»ºæ–°çš„å˜æ¢ï¼Œä¿æŒä¸­å¿ƒç‚¹ä¸å˜
                    const newTransform = d3.zoomIdentity
                        .translate(centerX, centerY)
                        .scale(newScale)
                        .translate(-centerX, -centerY);
                    
                    // åº”ç”¨å˜æ¢
                    svg.call(d3.zoom().transform, newTransform);
                    
                    // ç«‹å³åº”ç”¨ç¼©æ”¾å˜æ¢åˆ°åœ°å›¾ç»„
                    svg.select(".map-group").attr("transform", newTransform);
                    
                    // æ›´æ–°å…¨å±€zoomçŠ¶æ€
                    currentZoom = newTransform;
                    zoomLevel = newScale;
                    updateZoomInfo();
                }
            }
        }
        
        function zoomOut() {
            if (zoomLevel > MIN_ZOOM) {
                const svg = d3.select("#chart svg");
                if (!svg.empty()) {
                    // è·å–SVGçš„å°ºå¯¸å’Œå½“å‰zoomçŠ¶æ€
                    const width = parseInt(svg.attr("width"));
                    const height = parseInt(svg.attr("height"));
                    const currentTransform = d3.zoomTransform(svg.node());
                    
                    // è®¡ç®—æ–°çš„ç¼©æ”¾æ¯”ä¾‹
                    const newScale = Math.max(MIN_ZOOM, currentTransform.k * 0.75);
                    
                    // ä»¥åœ°å›¾ä¸­å¿ƒä¸ºç¼©æ”¾ä¸­å¿ƒ
                    const centerX = width / 2;
                    const centerY = height / 2;
                    
                    // åˆ›å»ºæ–°çš„å˜æ¢ï¼Œä¿æŒä¸­å¿ƒç‚¹ä¸å˜
                    const newTransform = d3.zoomIdentity
                        .translate(centerX, centerY)
                        .scale(newScale)
                        .translate(-centerX, -centerY);
                    
                    // åº”ç”¨å˜æ¢
                    svg.call(d3.zoom().transform, newTransform);
                    
                    // ç«‹å³åº”ç”¨ç¼©æ”¾å˜æ¢åˆ°åœ°å›¾ç»„
                    svg.select(".map-group").attr("transform", newTransform);
                    
                    // æ›´æ–°å…¨å±€zoomçŠ¶æ€
                    currentZoom = newScale;
                    zoomLevel = newScale;
                    updateZoomInfo();
                }
            }
        }
        
        function resetZoom() {
            const svg = d3.select("#chart svg");
            if (!svg.empty()) {
                // ä½¿ç”¨ç°æœ‰çš„zoomè¡Œä¸ºé‡ç½®
                svg.call(d3.zoom().transform, d3.zoomIdentity);
                
                // ç«‹å³åº”ç”¨ç¼©æ”¾å˜æ¢åˆ°åœ°å›¾ç»„
                svg.select(".map-group").attr("transform", d3.zoomIdentity);
                
                // æ›´æ–°å…¨å±€zoomçŠ¶æ€
                currentZoom = d3.zoomIdentity;
                zoomLevel = 1;
                updateZoomInfo();
            }
        }
        
        // ç¼©æ”¾æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        
        if (resetZoomBtn) resetZoomBtn.addEventListener('click', resetZoom);

        // åˆå§‹åŒ–
        initChart();
        updateDetailPanelPosition(); // åˆå§‹åŒ–æ—¶è®¾ç½®detail panelä½ç½®
        updateZoomInfo(); // åˆå§‹åŒ–ç¼©æ”¾ä¿¡æ¯

        // åˆ›å»ºè‡ªå®šä¹‰ä¸‹æ‹‰æ¡†
        function createCustomSelects() {
            const selects = document.querySelectorAll('.control-group select');
            
            selects.forEach(select => {
                // åˆ›å»ºè‡ªå®šä¹‰ä¸‹æ‹‰æ¡†å®¹å™¨
                const customSelect = document.createElement('div');
                customSelect.className = 'custom-select';
                customSelect.style.cssText = `
                    position: relative;
                    display: inline-block;
                    min-width: ${Math.max(select.offsetWidth, 80)}px;
                    font-family: inherit;
                `;
                
                // åˆ›å»ºæ˜¾ç¤ºåŒºåŸŸ
                const selectDisplay = document.createElement('div');
                selectDisplay.className = 'select-display';
                selectDisplay.style.cssText = `
                    padding: 6px 10px;
                    border: 2px solid #e9ecef;
                    border-radius: 4px;
                    background: white;
                    cursor: pointer;
                    user-select: none;
                    position: relative;
                    font-size: 13px;
                    font-weight: 500;
                    color: #374151;
                    letter-spacing: 0.025em;
                    transition: all 0.3s ease;
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
                    min-width: 80px;
                    max-width: 120px;
                `;
                
                // æ·»åŠ ä¸‹æ‹‰ç®­å¤´
                const arrow = document.createElement('span');
                arrow.innerHTML = 'â–¼';
                arrow.style.cssText = `
                    position: absolute;
                    right: 8px;
                    top: 50%;
                    transform: translateY(-50%);
                    font-size: 10px;
                    color: #6b7280;
                    transition: transform 0.3s ease;
                `;
                
                selectDisplay.appendChild(arrow);
                selectDisplay.appendChild(document.createTextNode(select.options[select.selectedIndex].text));
                
                // åˆ›å»ºä¸‹æ‹‰é€‰é¡¹åˆ—è¡¨
                const optionsList = document.createElement('div');
                optionsList.className = 'select-options';
                optionsList.style.cssText = `
                    position: absolute;
                    top: 100%;
                    left: 0;
                    right: 0;
                    background: white;
                    border: 2px solid #e9ecef;
                    border-top: none;
                    border-radius: 0 0 4px 4px;
                    max-height: 200px;
                    overflow-y: auto;
                    z-index: 9999;
                    opacity: 0;
                    visibility: hidden;
                    transform: translateY(-10px);
                    transition: all 0.3s ease;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                `;
                
                // æ·»åŠ é€‰é¡¹
                Array.from(select.options).forEach((option, index) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'select-option';
                    optionDiv.textContent = option.text;
                    optionDiv.style.cssText = `
                        padding: 10px 12px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        border-bottom: 1px solid #f3f4f6;
                        font-size: 13px;
                        color: #374151;
                    `;
                    
                    // æ‚¬åœæ•ˆæœ
                    optionDiv.addEventListener('mouseenter', function() {
                        this.style.backgroundColor = '#f3f4f6';
                        this.style.color = '#1f2937';
                    });
                    
                    optionDiv.addEventListener('mouseleave', function() {
                        this.style.backgroundColor = 'white';
                        this.style.color = '#374151';
                    });
                    
                    // ç‚¹å‡»é€‰æ‹©
                    optionDiv.addEventListener('click', function() {
                        select.value = option.value;
                        selectDisplay.textContent = option.text;
                        selectDisplay.appendChild(arrow);
                        
                        // è§¦å‘changeäº‹ä»¶
                        const event = new Event('change', { bubbles: true });
                        select.dispatchEvent(event);
                        
                        // éšè—é€‰é¡¹åˆ—è¡¨
                        toggleOptions();
                    });
                    
                    optionsList.appendChild(optionDiv);
                });
                
                // åˆ‡æ¢é€‰é¡¹åˆ—è¡¨æ˜¾ç¤º/éšè—
                let isOpen = false;
                function toggleOptions() {
                    isOpen = !isOpen;
                    if (isOpen) {
                        optionsList.style.opacity = '1';
                        optionsList.style.visibility = 'visible';
                        optionsList.style.transform = 'translateY(0)';
                        arrow.style.transform = 'translateY(-50%) rotate(180deg)';
                        selectDisplay.style.borderColor = '#2E86AB';
                        selectDisplay.style.boxShadow = '0 0 0 3px rgba(46, 134, 171, 0.15), 0 4px 8px rgba(0, 0, 0, 0.1)';
                    } else {
                        optionsList.style.opacity = '0';
                        optionsList.style.visibility = 'hidden';
                        optionsList.style.transform = 'translateY(-10px)';
                        arrow.style.transform = 'translateY(-50%) rotate(0deg)';
                        selectDisplay.style.borderColor = '#e9ecef';
                        selectDisplay.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.05)';
                    }
                }
                
                // ç‚¹å‡»æ˜¾ç¤ºåŒºåŸŸåˆ‡æ¢é€‰é¡¹
                selectDisplay.addEventListener('click', toggleOptions);
                
                // æ‚¬åœæ•ˆæœ
                selectDisplay.addEventListener('mouseenter', function() {
                    if (!isOpen) {
                        this.style.borderColor = '#d1d5db';
                        this.style.backgroundColor = '#fafbfc';
                        this.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
                        this.style.transform = 'translateY(-1px)';
                    }
                });
                
                selectDisplay.addEventListener('mouseleave', function() {
                    if (!isOpen) {
                        this.style.borderColor = '#e9ecef';
                        this.style.backgroundColor = 'white';
                        this.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.05)';
                        this.style.transform = 'translateY(0)';
                    }
                });
                
                // ç»„è£…è‡ªå®šä¹‰ä¸‹æ‹‰æ¡†
                customSelect.appendChild(selectDisplay);
                customSelect.appendChild(optionsList);
                
                // æ›¿æ¢åŸå§‹select
                select.style.display = 'none';
                select.parentNode.insertBefore(customSelect, select);
                
                // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰æ¡†
                document.addEventListener('click', function(e) {
                    if (!customSelect.contains(e.target)) {
                        if (isOpen) {
                            toggleOptions();
                        }
                    }
                });
            });
        }

        // ç›‘å¬çª—å£å¤§å°å˜åŒ–
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                initChart();
                updateDetailPanelPosition(); // çª—å£å¤§å°æ”¹å˜æ—¶æ›´æ–°detail panelä½ç½®
                updateZoomInfo(); // æ›´æ–°ç¼©æ”¾ä¿¡æ¯
            }, 250);
        });
        
        // é¡µé¢åŠ è½½å®Œæˆååˆ›å»ºè‡ªå®šä¹‰ä¸‹æ‹‰æ¡†
        window.addEventListener('load', function() {
            setTimeout(createCustomSelects, 100);
        });
    </script>
</body>
</html> 
