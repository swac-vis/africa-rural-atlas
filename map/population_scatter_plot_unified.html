<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Africa Population Distribution</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            overflow: hidden;
        }
        .container {
            width: 100vw;
            height: 100vh;
            background-color: white;
            display: flex;
            flex-direction: column;
        }
        h1 {
            text-align: center;
            color: #333;
            margin: 10px 0;
            font-size: clamp(16px, 3vw, 24px);
            padding: 0 10px;
        }
        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
            margin-bottom: 15px;
            padding: 20px 24px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border-radius: 12px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            flex-wrap: wrap;
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 9998;
            transition: all 0.3s ease;
        }
        
        .controls.collapsed {
            padding: 8px 24px;
            margin-bottom: 5px;
        }
        
        .controls.collapsed .control-group {
            display: none;
        }
        
        .controls.collapsed .collapse-btn {
            transform: rotate(180deg);
        }
        
        .collapse-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            background: transparent;
            border: none;
            cursor: pointer;
            opacity: 0.4;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #64748b;
        }
        
        .collapse-btn:hover {
            opacity: 0.7;
        }
        
        .collapse-btn::before {
            content: "▼";
            font-size: 8px;
        }
        
        /* Zoom control styles */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: row;
            gap: 5px;
            z-index: 9997;
            transition: all 0.3s ease;
        }
        
        .zoom-controls.with-details {
            right: calc(400px + 20px); /* 400px is the width of detail panel + 20px margin */
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .zoom-btn:hover {
            background: #f0f0f0;
            border-color: #999;
        }
        
        .zoom-btn:active {
            transform: scale(0.95);
        }
        
        .zoom-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* SVG legend styles in legend */
        .figure-container {
            
        }
        
        .figure-container foreignObject {
            overflow: visible;
        }
        
        .figure-container svg {
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        /* Data Source Footer Styles */
        .data-source-footer {
            background: #f8fafc;
            border-top: 1px solid #e2e8f0;
            padding: 5px 10px;
            font-size: 8px;
            color: #64748b;
            margin-top: auto;
        }
        
        .data-source a {
            color: #2E86AB;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.2s ease;
        }
        
        .data-source a:hover {
            color: #1e5a7a;
            text-decoration: underline;
        }
        
        .data-note {
            font-style: italic;
            color: #94a3b8;
            margin-top: 3px;
        }
        
        @media (max-width: 768px) {
            .data-source-footer {
                padding: 12px 15px;
            }
        }
        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 18px;
            margin-bottom: 15px;
            padding: 10px 18px;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 8px;
            border: 1px solid #e9ecef;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-group label {
            font-weight: 500;
            font-size: 12px;
            color: #495057;
            white-space: nowrap;
            letter-spacing: 0.3px;
        }
        
        /* Base styles */
        .control-group input {
            padding: 4px 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 12px;
            background-color: white;
            transition: all 0.2s ease;
            min-width: 80px;
            position: relative;
        }
        
        .control-group input:hover {
            border-color: #adb5bd;
        }
        
        .control-group input:focus {
            outline: none;
            border-color: #2E86AB;
            box-shadow: 0 0 0 2px rgba(46, 134, 171, 0.1);
        }
        
        /* Select-specific styles - using higher priority */
        .control-group select {
            padding: 6px 10px;
            border: 2px solid #e9ecef;
            border-radius: 4px;
            font-size: 13px;
            background-color: white;
            transition: all 0.3s ease;
            min-width: 80px;
            position: relative;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 16px;
            padding-right: 28px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            text-indent: 2px;
            font-weight: 500;
            color: #374151;
            letter-spacing: 0.025em;
        }
        
        .control-group select:hover {
            border-color: #d1d5db;
            background-color: #fafbfc;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .control-group select:active {
            background-color: #f8f9fa;
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .control-group select:focus {
            outline: none;
            border-color: #2E86AB;
            box-shadow: 0 0 0 3px rgba(46, 134, 171, 0.15), 0 4px 8px rgba(0, 0, 0, 0.1);
            background-color: white;
        }
        
        /* Try to customize dropdown option styles (partially supported by browsers) */
        .control-group select option {
            background-color: white !important;
            color: #374151 !important;
            font-size: 13px !important;
            padding: 12px 16px !important;
            border: none !important;
            font-weight: 400 !important;
            transition: all 0.2s ease !important;
        }
        
        .control-group select option:hover {
            background-color: #f3f4f6 !important;
            color: #1f2937 !important;
        }
        
        .control-group select option:checked {
            background: linear-gradient(135deg, #2E86AB 0%, #1e5a7a 100%) !important;
            color: white !important;
            font-weight: 600 !important;
        }
        
        .control-group select option:selected {
            background: linear-gradient(135deg, #2E86AB 0%, #1e5a7a 100%) !important;
            color: white !important;
            font-weight: 600 !important;
        }
        
        /* Add specific styles for different browsers */
        .control-group select::-ms-expand {
            display: none;
        }
        
        /* Firefox-specific styles */
        .control-group select:-moz-focusring {
            color: transparent;
            text-shadow: 0 0 0 #374151;
        }
        
        /* Add focus indicator for dropdown */
        .control-group select:focus-visible {
            outline: 2px solid #2E86AB;
            outline-offset: 2px;
        }
        
        /* Add label styles for dropdown */
        .control-group label {
            font-weight: 600;
            font-size: 13px;
            color: #374151;
            white-space: nowrap;
            letter-spacing: 0.025em;
            margin-bottom: 4px;
            display: block;
        }
        
        /* Control group container style optimization */
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 6px;
            min-width: 100px;
            position: relative;
            z-index: 9999;
        }
        
        /* Enhanced dropdown styles */
        .control-group select {
            position: relative;
            overflow: hidden;
        }
        
        /* Add gradient border effect for dropdown */
        .control-group select::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 6px;
            padding: 2px;
            background: linear-gradient(135deg, #2E86AB, #1e5a7a);
            -webkit-mask: 
                linear-gradient(#fff 0 0) content-box, 
                linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .control-group select:focus::before {
            opacity: 1;
        }
        
        /* Add inner shadow effect for dropdown */
        .control-group select {
            box-shadow: 
                inset 0 1px 2px rgba(255, 255, 255, 0.8),
                0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        /* Subtle animation when dropdown is hovered */
        .control-group select:hover {
            animation: selectHover 0.3s ease forwards;
        }
        
        @keyframes selectHover {
            0% { transform: translateY(0); }
            50% { transform: translateY(-2px); }
            100% { transform: translateY(-1px); }
        }
        
        /* Add different border colors for different dropdown states */
        .control-group select:invalid {
            border-color: #ef4444;
        }
        
        .control-group select:valid {
            border-color: #10b981;
        }
        
        /* Responsive design optimization */
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                gap: 16px;
                padding: 16px 20px;
            }
            
            .control-group {
                min-width: 100%;
                align-items: center;
            }
            
            .control-group select {
                min-width: 200px;
                text-align: center;
            }
        }
        
        /* Range input styles */
        .control-group input[type="range"] {
            width: 70px;
            height: 4px;
            border-radius: 2px;
            background: linear-gradient(to right, #dee2e6 0%, #dee2e6 100%);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #2E86AB 0%, #1e5a7a 100%);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            background: linear-gradient(135deg, #1e5a7a 0%, #0d3d5a 100%);
            transform: scale(1.1);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }
        
        .control-group input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #2E86AB 0%, #1e5a7a 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .control-group span {
            font-size: 11px;
            color: #6c757d;
            min-width: 35px;
            text-align: center;
        }
        
        /* Adjust chart container when controls are collapsed */
        .controls.collapsed + .chart-container {
            margin-top: -10px; /* Compensate for reduced controls height */
        }
        
        /* Ensure smooth transition for chart container */
        .chart-container {
            flex: 1;
            width: 100%;
            position: relative;
            min-height: 300px;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        /* Force chart container to take remaining space */
        .container:has(.controls.collapsed) .chart-container {
            flex: 1;
            min-height: calc(100vh - 120px); /* Adjust based on collapsed controls height */
        }
        
        .legend {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 80px;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            z-index: 1000;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: clamp(10px, 2vw, 12px);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 200px;
            z-index: 1000;
        }
        
        /* Detail panel styles */
        .detail-panel {
            position: fixed;
            right: 0;
            width: 400px;
            min-width: 400px;
            background: white;
            border-left: 0.5px solid #ddd;
            z-index: 9996;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .detail-panel.show {
            transform: translateX(0);
        }
        
        .detail-panel-header {
            padding: 15px 20px;
            border-bottom: 2px solid #f0f0f0;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .detail-panel-title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin: 0;
        }
        
        .detail-panel-close {
            position: absolute;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 5px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .detail-panel-close:hover {
            background: #f0f0f0;
            color: #333;
        }
        
        .detail-panel-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .detail-panel-section {
            margin-bottom: 25px;
        }
        
        .detail-panel-section h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 16px;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }
        
        .detail-panel-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px 0;
        }
        
        .detail-panel-label {
            font-weight: 600;
            color: #555;
            font-size: 14px;
        }
        
        .detail-panel-value {
            color: #333;
            text-align: right;
            font-size: 14px;
        }
        
        .detail-panel-chart {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .detail-panel-chart > div {
            width: 100%;
            overflow: hidden;
        }
        
        #detailPanelChartContainer,
        #detailPanelDensityChartContainer,
        #detailPanelAreaChartContainer {
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }
        
        #detailPanelChartContainer svg,
        #detailPanelDensityChartContainer svg,
        #detailPanelAreaChartContainer svg {
            max-width: 100%;
            height: auto;
        }
        
        .detail-panel-chart h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 16px;
        }
        
        /* Zoom view container */
        .zoom-view {
            width: 100%;
            height: 200px;
            background: #fff;
            border-radius: 8px;
            border: 0.5px solid #ddd;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        .zoom-view svg {
            max-width: 100%;
            max-height: 100%;
        }
        
        /* Click effects */
        .cell-clickable {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .cell-clickable:hover {
            filter: brightness(1.2) drop-shadow(0 0 8px rgba(0, 0, 0, 0.3));
        }
        
        .cell-clickable:hover circle {
            stroke: #0b4eca;
            stroke-width: 1;
        }
        
        .cell-clickable.selected {
            filter: brightness(1.1) drop-shadow(0 0 6px rgba(11, 78, 202, 0.3));
        }
        
        .cell-clickable.selected circle {
            stroke: #0b4eca;
            stroke-width: 1;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            .control-group {
                flex-direction: column;
                align-items: flex-start;
            }
            h1 {
                font-size: 18px;
                margin: 5px 0;
            }
            .detail-panel {
                width: 100%;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 16px;
                margin: 3px 0;
            }
            .detail-panel {
                width: 100%;
            }
        }
        
        /* Custom dropdown styles */
        .custom-select {
            position: relative;
            display: inline-block;
            font-family: inherit;
            z-index: 9999;
            min-width: 80px;
        }
        
        .select-display {
            padding: 6px 10px;
            border: 2px solid #e9ecef;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            user-select: none;
            position: relative;
            font-size: 13px;
            font-weight: 500;
            color: #374151;
            letter-spacing: 0.025em;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            min-width: 80px;
            max-width: 120px;
        }
        
        .select-display:hover {
            border-color: #d1d5db;
            background-color: #fafbfc;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .select-display:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .select-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e9ecef;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .select-option {
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 1px solid #f3f4f6;
            font-size: 13px;
            color: #374151;
        }
        
        .select-option:hover {
            background-color: #f3f4f6;
            color: #1f2937;
        }
        
        .select-option:last-child {
            border-bottom: none;
        }
        
        /* Scrollbar styles */
        .select-options::-webkit-scrollbar {
            width: 6px;
        }
        
        .select-options::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        .select-options::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }
        
        .select-options::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        
        /* Z-Index layering system
         * 9999: Custom dropdown option list (highest priority)
         * 9998: Control group container
         * 9997: Control panel (.controls)
         * 9996: Zoom control buttons (.zoom-controls)
         * 9995: Detail information panel (.detail-panel)
         * 1000: Legend (.legend) and tooltip (.tooltip)
         * 100: Map elements and other basic components
         */
        
        /* Ensure dropdown is above all elements */
        .custom-select,
        .select-display,
        .select-options,
        .select-option {
            position: relative;
            z-index: 9999 !important;
        }
        
        /* Ensure control panel is at correct layer */
        .controls {
            z-index: 9997 !important;
        }
        
        .control-group {
            z-index: 9998 !important;
        }
        
        /* Ensure zoom controls don't block dropdown */
        .zoom-controls {
            z-index: 9996 !important;
        }
        
        /* Ensure detail panel doesn't block dropdown */
        .detail-panel {
            z-index: 9995 !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Africa Population Distribution</h1>
        <div class="controls">
            <div class="control-group">
                <label>Grid Size:</label>
                <select id="gridSize">
                    <option value="100">100km</option>
                    <option value="1000">1000km</option>
                </select>
            </div>
            <div class="control-group">
                <label>Color Mapping:</label>
                <select id="colorMapping">
                    <option value="density">Density</option>
                    <option value="population">Population</option>
                </select>
            </div>
            <div class="control-group">
                <label>Visualization Mode:</label>
                <select id="visualizationMode">
                    <option value="scatter">Scatter Plot</option>
                    <option value="concentric">Concentric Circles</option>
                    <option value="rect">Rectangle</option>
                </select>
            </div>
            <div class="control-group">
                <label>Area Data:</label>
                <select id="areaData">
                    <option value="true">Use Real Area</option>
                    <option value="false">Use Fixed Area</option>
                </select>
            </div>
            <div class="control-group">
                <label>Circle Size:</label>
                <input type="range" id="circleSize" min="0.1" max="0.6" step="0.1" value="0.2">
                <span id="circleSizeValue">0.2</span>
            </div>
            <div class="control-group">
                <label>Circle Spacing:</label>
                <input type="range" id="circleSpacing" min="0.3" max="1.2" step="0.1" value="0.4">
                <span id="circleSpacingValue">0.4</span>
            </div>
            <div class="control-group">
                <label>Max Circles per Cell:</label>
                <input type="range" id="maxCircles" min="1" max="256" step="1" value="16">
                <span id="maxCirclesValue">16</span>
            </div>
            <button class="collapse-btn" id="collapseBtn" title="Collapse/Expand Controls"></button>
        </div>
        <div class="chart-container" id="chart">
            <!-- Zoom Control Buttons -->
            <div class="zoom-controls">
                <button class="zoom-btn" id="resetZoomBtn" title="Reset Zoom">⌂</button>
            </div>
        </div>
        
        <!-- Data Source and Notes -->
        <div class="data-source-footer">
            <div class="data-source">
                <a href="https://hub.worldpop.org/doi/10.5258/SOTON/WP00004" target="_blank" rel="noopener noreferrer">
                    Data from WorldPop | Africa Continental Population Dataset, 2020
                </a>
            </div>
            <div class="data-note">
                Note: Urban population refers to areas with a population density of at least 300 inhabitants per square kilometer. Rural population refers to all other areas.
            </div>
        </div>
    </div>

            <!-- Detail Information Right Panel -->
    <div class="detail-panel" id="detailPanel">
        <div class="detail-panel-header">
            <h2 class="detail-panel-title" id="detailPanelTitle">Cell Details</h2>
            <button class="detail-panel-close" id="closeDetailPanelBtn">&times;</button>
        </div>
        <div class="detail-panel-content">
            <div class="zoom-view" id="zoomView">
                <!-- Enlarged grid cells will be displayed here -->
            </div>
            <div class="detail-panel-section" id="detailPanelGrid">
                <!-- Detail information will be dynamically filled by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // Dynamically set detail panel position
        function updateDetailPanelPosition() {
            const detailPanel = document.getElementById('detailPanel');
            const header = document.querySelector('h1');
            const controls = document.querySelector('.controls');
            
            if (detailPanel && header && controls) {
                // Get actual height of header (including margin)
                const headerRect = header.getBoundingClientRect();
                const headerBottom = headerRect.bottom;
                
                // Get actual height of controls (including border)
                const controlsRect = controls.getBoundingClientRect();
                const controlsBottom = controlsRect.bottom;
                
                // Use controls bottom position as detail panel top position
                detailPanel.style.top = controlsBottom + 'px';
                detailPanel.style.height = `calc(100vh - ${controlsBottom}px)`;
            }
        }

        // Collapse/Expand controls functionality
        function setupCollapseControls() {
            const collapseBtn = document.getElementById('collapseBtn');
            const controls = document.querySelector('.controls');
            const chartContainer = document.querySelector('.chart-container');
            
            if (collapseBtn && controls && chartContainer) {
                collapseBtn.addEventListener('click', () => {
                    controls.classList.toggle('collapsed');
                    
                    // Immediately update detail panel position
                    updateDetailPanelPosition();
                    
                    // Adjust chart container height based on controls state
                    if (controls.classList.contains('collapsed')) {
                        // When collapsed, increase chart container height
                        chartContainer.style.height = 'calc(100vh - 80px)'; // Adjust based on collapsed controls height
                    } else {
                        // When expanded, restore normal height
                        chartContainer.style.height = 'calc(100vh - 140px)'; // Adjust based on expanded controls height
                    }
                    
                    // Force chart recalculation
                    setTimeout(() => {
                        window.dispatchEvent(new Event('resize'));
                    }, 100);
                });
            }
        }

        // Configuration parameters
        let currentConfig = {
            gridSize: '100',
            useRealArea: true,
            colorMapping: 'density',
            circleSize: 0.2,  // Default value for 100km
            circleSpacing: 0.4,  // Default value for 100km
            maxCircles: 16,  // Default value
            visualizationMode: 'scatter'  // New: visualization mode
        };

        // Zoom-related variables
        let currentZoom = d3.zoomIdentity;
        let zoomLevel = 1;
        const MIN_ZOOM = 0.2;
        const MAX_ZOOM = 10;
        
        // Currently displayed detail panel data
        let currentDetailCell = null;
        
        // Add window resize listener
        window.addEventListener('resize', () => {
            if (currentDetailCell) {
                setTimeout(resizeDetailCharts, 100); // Delay execution to ensure DOM update completion
            }
        });

        // User-defined color settings
        let customColorSettings = {
            population: {
                thresholds: currentConfig.gridSize === '1000' ? 
                    [100000, 500000, 1500000, 5000000, 10000000, 30000000] :
                    [1000, 5000, 15000, 50000, 100000, 300000],
                colors: ["#F7F7F7", "#E4E2BD", "#D7D394", "#BC8D42", "#A5682F", "#823624", "#501E1D"]
            },
            density: {
                thresholds: [1, 5, 15, 50, 100, 300],
                colors: ["#F7F7F7", "#E4E2BD", "#D7D394", "#BC8D42", "#A5682F", "#823624", "#501E1D"]
            }
        };

        // Dynamic endpoint value setting function
        function getDynamicEndpoint(gridData, colorMapping) {
            if (!gridData || gridData.length === 0) return 1000;
            
            let maxValue = 0;
            if (colorMapping === 'population') {
                maxValue = Math.max(...gridData.map(cell => 
                    Math.max(cell.urban_population || 0, cell.rural_population || 0)
                ));
            } else {
                // density mapping
                maxValue = Math.max(...gridData.map(cell => {
                    const urbanDensity = cell.urban_population && cell.urban_area ? 
                        cell.urban_population / cell.urban_area : 0;
                    const ruralDensity = cell.rural_population && cell.rural_area ? 
                        cell.rural_population / cell.rural_area : 0;
                    return Math.max(urbanDensity, ruralDensity);
                }));
            }
            
            // If maximum value is less than or equal to 300, set a reasonable default
            if (maxValue <= 300) {
                return colorMapping === 'population' ? 1000000 : 1000;
            }
            
            // Return a value slightly larger than the maximum to ensure >300 intervals can be displayed
            return Math.ceil(maxValue * 1.2);
        }

        // Abstract mapping strategy parameters
        const MAPPING_CONFIG = {
            maxCircles: 16,  // Default value, will be obtained from currentConfig
            urbanAreaShare: 0.2,
            ruralAreaShare: 0.8
        };

        // Responsive function
        function getResponsiveDimensions() {
            const container = document.querySelector('.chart-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Adjust area size based on gridSize
            const sizeMultiplier = currentConfig.gridSize === '100' ? 0.15 : 1;
            const baseAreaSize = Math.min(width, height) * sizeMultiplier;
            const areaSize = currentConfig.gridSize === '100' 
                ? Math.max(4, Math.min(15, baseAreaSize))
                : Math.max(20, Math.min(65, baseAreaSize));
            
            return { width, height, areaSize };
        }

        // Calculate circle count for each grid
        function calculateCircleCount(population, minPop, maxPop) {
            if (maxPop === minPop) return 1;
            
            const normalizedPop = (population - minPop) / (maxPop - minPop);
            const rawCount = normalizedPop * MAPPING_CONFIG.maxCircles;
            const sqrtCount = Math.sqrt(rawCount);
            const roundedSqrt = Math.floor(sqrtCount);
            const circleCount = Math.max(1, roundedSqrt * roundedSqrt);
            
            return circleCount;
        }

        // Generate circle positions in fixed area
        function generateCirclePositionsInFixedArea(circleCount, centerX, centerY, areaSize) {
            const positions = [];
            const gridSize = Math.ceil(Math.sqrt(circleCount));
            
            const circleRadius = (areaSize / gridSize) * currentConfig.circleSize;
            const spacing = (areaSize / gridSize) * currentConfig.circleSpacing;
            
            const allPositions = [];
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x = centerX - areaSize/2 + (j + 0.5) * spacing;
                    const y = centerY - areaSize/2 + (i + 0.5) * spacing;
                    allPositions.push({ x, y, i, j });
                }
            }
            
            const centerI = Math.floor(gridSize / 2);
            const centerJ = Math.floor(gridSize / 2);
            allPositions.sort((a, b) => {
                const distA = Math.sqrt((a.i - centerI) ** 2 + (a.j - centerJ) ** 2);
                const distB = Math.sqrt((b.i - centerI) ** 2 + (b.j - centerJ) ** 2);
                return distA - distB;
            });
            
            for (let idx = 0; idx < circleCount; idx++) {
                const pos = allPositions[idx];
                positions.push({ 
                    x: pos.x, 
                    y: pos.y, 
                    radius: circleRadius, 
                    spiralIndex: idx 
                });
            }
            
            return positions;
        }

        // Calculate density or population value
        function calculateValue(cell, isUrban) {
            if (currentConfig.colorMapping === 'population') {
                return isUrban ? cell.urban_population : cell.rural_population;
            } else {
                // density mapping - regardless of whether real area is used, should use real density values
                const area = isUrban ? cell.urban_area : cell.rural_area;
                const population = isUrban ? cell.urban_population : cell.rural_population;
                return area > 0 ? population / area : 0;
            }
        }

        // Create color scale
        function createColorScale(gridData) {
            // Use user-defined color settings
            const settings = customColorSettings[currentConfig.colorMapping];
            
            // Get dynamic endpoint values
            const dynamicEndpoint = getDynamicEndpoint(gridData, currentConfig.colorMapping);
            
            // Create extended threshold array including dynamic endpoint
            const extendedThresholds = [...settings.thresholds, dynamicEndpoint];
            
            // Create custom color scale supporting linear interpolation within intervals
            const colorScale = function(value) {
                if (value <= 0) return settings.colors[0];
                
                // Find the interval where the value is located
                for (let i = 0; i < extendedThresholds.length; i++) {
                    if (value <= extendedThresholds[i]) {
                        if (i === 0) {
                            // First interval: 0 to first threshold
                            const ratio = value / extendedThresholds[i];
                            return d3.interpolateRgb(settings.colors[0], settings.colors[1])(ratio);
                        } else {
                            // Other intervals: between two thresholds
                            const prevThreshold = extendedThresholds[i - 1];
                            const currThreshold = extendedThresholds[i];
                            const ratio = (value - prevThreshold) / (currThreshold - prevThreshold);
                            return d3.interpolateRgb(settings.colors[i], settings.colors[i + 1])(ratio);
                        }
                    }
                }
                
                // Values exceeding maximum threshold
                return settings.colors[settings.colors.length - 1];
            };
            
            return colorScale;
        }

        // Create legend
        function createLegend(svg, colorScale, maxValue) {
            const legendWidth = 160; // Reduce width, keep minimal
            const legendHeight = 200;

            // Remove old legend
            svg.selectAll(".legend").remove();

            const legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(20, 20)`);

            // Add encoding rule description
            legend.append("text")
                .attr("x", 0)
                .attr("y", 15)
                .attr("font-size", "10px")
                .attr("font-weight", "500")
                .attr("fill", "#495057")
                .text("Visualization Rules:");

            // Load and display visualization mode legend
            const figureContainer = legend.append("g")
                .attr("class", "figure-container")
                .attr("transform", "translate(0, 25)");

            // Select corresponding legend based on current configuration
            const getFigurePath = () => {
                const mode = currentConfig.visualizationMode;
                const size = currentConfig.gridSize;
                
                if (mode === 'scatter') {
                    return size === '100' ? 'figures/scatter_100.svg' : 'figures/scatter_1000.svg';
                } else if (mode === 'concentric') {
                    return size === '100' ? 'figures/concentric_100.svg' : 'figures/concentric_1000.svg';
                } else if (mode === 'rect') {
                    return size === '100' ? 'figures/rect_100.svg' : 'figures/rect_1000.svg';
                }
                return 'figures/scatter_100.svg'; // Default
            };

            // Create legend container
            const legendFigure = figureContainer.append("foreignObject")
                .attr("x", -20)
                .attr("y", 0)
                .attr("width", 400)
                .attr("height", 150);

            // Load SVG legend
            const figurePath = getFigurePath();
            fetch(figurePath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(svgContent => {
                    // Create temporary div to parse SVG
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = svgContent;
                    const svgElement = tempDiv.querySelector('svg');
                    
                    if (svgElement) {
                        // Adjust SVG size and style
                        svgElement.style.width = '100%';
                        svgElement.style.height = 'auto';
                        svgElement.style.maxHeight = '120px';
                        
                        // Insert SVG content into foreignObject
                        legendFigure.node().appendChild(svgElement);
                    } else {
                        throw new Error('SVG element not found in response');
                    }
                })
                .catch(error => {
                    console.error('Error loading figure:', error);
                    // If loading fails, display fallback text
                    figureContainer.append("text")
                        .attr("x", 0)
                        .attr("y", 35)
                        .attr("font-size", "9px")
                        .attr("fill", "#666")
                        .text("• Visualization mode: " + currentConfig.visualizationMode);
                });

            // Generate segments using custom color settings
            const settings = customColorSettings[currentConfig.colorMapping];
            const thresholds = settings.thresholds;
            const colors = settings.colors;
            
            // Get dynamic endpoint values
            const dynamicEndpoint = getDynamicEndpoint(window.gridData || [], currentConfig.colorMapping);
            
            // Redesign: treat 0 as the first threshold, as the endpoint of the first interval, and add dynamic endpoint
            const allThresholds = [0, ...thresholds, dynamicEndpoint]; // 0 + original thresholds + dynamic endpoint
            const allColors = [...colors]; // Keep original color array
            
            // Use global variable to store segments
            window.currentSegments = [];
            let title = currentConfig.colorMapping === 'population' ? 'Population' : 'Population/km²';
            
            // Generate segments - now 0 is the endpoint of the first interval
            for (let i = 0; i < allThresholds.length - 1; i++) {
                if (i === allThresholds.length - 2) {
                    // Last interval: greater than the last threshold (preserve >300 intervals)
                    const lastThreshold = allThresholds[allThresholds.length - 1];
                    if (lastThreshold === 300) {
                    window.currentSegments.push({ 
                            label: `>300`, 
                        color: allColors[i + 1] 
                    });
                    } else {
                        window.currentSegments.push({ 
                            label: `>${lastThreshold}`, 
                            color: allColors[i + 1] 
                        });
                    }
                } else {
                    // Other intervals: between two thresholds
                    window.currentSegments.push({ 
                        label: `${allThresholds[i]}-${allThresholds[i + 1]}`, 
                        color: allColors[i + 1] 
                    });
                }
            }

            legend.append("text")
                .attr("x", 0)
                .attr("y", 200)
                .attr("font-size", "9px")
                .attr("font-weight", "500")
                .attr("fill", "#495057")
                .text(title + " Scale:");

            // Create continuous color slider editor
            const colorEditor = legend.append("g")
                .attr("class", "color-editor");
            
            // Basic slider settings (vertical)
            const sliderWidth = 16;
            const sliderHeight = 350;
            const sliderY = 220;
            const sliderX = 0;
            
            // Create slider background
            const sliderBackground = colorEditor.append("rect")
                .attr("x", sliderX)
                .attr("y", sliderY)
                .attr("width", sliderWidth)
                .attr("height", sliderHeight)
                .attr("fill", "#f8f9fa")
                .attr("stroke", "#e9ecef")
                .attr("stroke-width", 1)
                .attr("rx", 2);
            
            // Create gradient background (vertical)
            const gradient = colorEditor.append("defs")
                .append("linearGradient")
                .attr("id", "colorGradient")
                .attr("x1", "0%")
                .attr("y1", "100%")
                .attr("x2", "0%")
                .attr("y2", "0%");
            
            // Add gradient stop points
            colors.forEach((color, i) => {
                const offset = (i / (colors.length - 1)) * 100;
                gradient.append("stop")
                    .attr("offset", offset + "%")
                    .attr("stop-color", color);
            });
            
            // Create gradient slider
            const gradientSlider = colorEditor.append("rect")
                .attr("x", sliderX + 1)
                .attr("y", sliderY + 1)
                .attr("width", sliderWidth - 2)
                .attr("height", sliderHeight - 2)
                .attr("fill", "url(#colorGradient)")
                .attr("rx", 1);
            
            // Remove additional endpoint color modification buttons, keep only slider and threshold markers
            
            // Create threshold markers
            const thresholdMarkers = colorEditor.append("g")
                .attr("class", "threshold-markers");
            
            // Delete the original starting point marker, because 0 is now a real threshold
            
            // Create markers for each threshold (including 0)
            allThresholds.forEach((threshold, i) => {
                // Position markers based on color position on slider
                // Now 0 is the first threshold, positioned at the bottom
                const colorPosition = i / (allThresholds.length - 1); // Position between 0 and 1
                const y = sliderY + sliderHeight - colorPosition * sliderHeight;
                
                // Create marker
                const marker = thresholdMarkers.append("circle")
                    .attr("cx", sliderX + sliderWidth / 2)
                    .attr("cy", y)
                    .attr("r", 4)
                    .attr("fill", allColors[i]) // Fill marker with corresponding color
                    .attr("stroke", "#6c757d")
                    .attr("stroke-width", 1)
                    .style("cursor", "pointer")
                    .attr("data-threshold-index", i);
                
                // Add delete button (except first, last and dynamic endpoint)
                if (i > 0 && i < allThresholds.length - 2) {
                    const deleteBtn = thresholdMarkers.append("text")
                        .attr("x", sliderX + sliderWidth / 2 + 8)
                        .attr("y", y - 8)
                        .attr("font-size", "10px")
                        .attr("fill", "#adb5bd")
                        .style("cursor", "pointer")
                        .text("×")
                        .on("click", function() {
                            // Delete threshold (need to adjust index because allThresholds includes 0 and dynamic endpoint)
                            const thresholdIndex = i - 1; // Subtract 0's index
                            if (thresholdIndex >= 0 && thresholdIndex < thresholds.length) {
                                // Save 0's color to ensure it won't be deleted
                                const zeroColor = colors[0];
                                
                                thresholds.splice(thresholdIndex, 1);
                                colors.splice(thresholdIndex, 1);
                                
                                // Ensure 0's color remains unchanged
                                if (colors[0] !== zeroColor) {
                                    colors[0] = zeroColor;
                                }
                                
                            updateLegendFigure();
                            updateColorScale();
                            }
                        });
                }
                
                // Add threshold label
                const label = thresholdMarkers.append("text")
                    .attr("x", sliderX + sliderWidth + 15)
                    .attr("y", y)
                    .attr("text-anchor", "start")
                    .attr("font-size", "9px")
                    .attr("fill", "#495057")
                    .style("cursor", i === allThresholds.length - 1 ? "default" : "pointer")
                    .text(threshold)
                    .on("click", function() {
                        // Dynamic endpoint cannot edit value but can edit color
                        if (i === allThresholds.length - 1) return;
                        
                        // Edit threshold
                        const input = document.createElement("input");
                        input.type = "number";
                        input.value = threshold;
                        input.style.position = "absolute";
                        input.style.left = (event.pageX - 10) + "px";
                        input.style.top = (event.pageY - 10) + "px";
                        input.style.width = "60px";
                        input.style.fontSize = "10px";
                        input.style.zIndex = "10000";
                        
                        input.addEventListener("change", function() {
                            const newValue = parseInt(this.value);
                            if (newValue > 0) {
                                // Need to adjust index because allThresholds includes 0 and dynamic endpoint
                                const thresholdIndex = i - 1; 
                                if (thresholdIndex >= 0 && thresholdIndex < thresholds.length) {
                                    // Save 0's color to ensure it won't be changed
                                    const zeroColor = colors[0];
                                    
                                    thresholds[thresholdIndex] = newValue;
                                                                    // Reorder thresholds
                                thresholds.sort((a, b) => a - b);
                                    
                                    // Ensure 0's color remains unchanged
                                    if (colors[0] !== zeroColor) {
                                        colors[0] = zeroColor;
                                    }
                                    
                                updateLegendFigure();
                                updateColorScale();
                                }
                            }
                            // Safely remove input box
                            if (document.body.contains(this)) {
                                document.body.removeChild(this);
                            }
                        });
                        
                        input.addEventListener("blur", function() {
                            // Delay removal to avoid conflict with change event
                            setTimeout(() => {
                                if (document.body.contains(this)) {
                                    document.body.removeChild(this);
                                }
                            }, 100);
                        });
                        
                        document.body.appendChild(input);
                        input.focus();
                        input.select();
                    });
                
                // Add color selection button (each marker can manually select color, including dynamic endpoint)
                const colorBtn = thresholdMarkers.append("text")
                    .attr("x", sliderX + sliderWidth / 2 + 8)
                    .attr("y", y + 8)
                    .attr("font-size", "10px")
                    .attr("fill", "#6f42c1")
                    .style("cursor", "pointer")
                    .text("🎨")
                    .on("click", function(event) {
                        // Create color picker
                        const colorInput = document.createElement("input");
                        colorInput.type = "color";
                        colorInput.value = colors[i];
                        colorInput.style.position = "absolute";
                        colorInput.style.left = (event.pageX - 10) + "px";
                        colorInput.style.top = (event.pageY - 10) + "px";
                        colorInput.style.zIndex = "10000";
                        
                        colorInput.addEventListener("change", function() {
                            // Update color
                            colors[i] = this.value;
                            
                            // Update marker color
                            marker.attr("fill", colors[i]);
                            
                            // Update gradient background
                            updateGradientBackground();
                            
                            // Update color scale and map
                            updateColorScale();
                            
                            // Safely remove input box
                            if (document.body.contains(this)) {
                                document.body.removeChild(this);
                            }
                        });
                        
                        colorInput.addEventListener("blur", function() {
                            // Delay removal to avoid conflict with change event
                            setTimeout(() => {
                                if (document.body.contains(this)) {
                                    document.body.removeChild(this);
                                }
                            }, 100);
                        });
                        
                        document.body.appendChild(colorInput);
                        colorInput.focus();
                        colorInput.click();
                    });
                
                // Add drag functionality - modify to adjust color instead of position (dynamic endpoint cannot be dragged)
                                  if (i < allThresholds.length - 1) { // Dynamic endpoint cannot be dragged
                marker.call(d3.drag()
                    .on("drag", function(event) {
                        // Calculate color corresponding to drag position
                        const dragY = Math.max(sliderY, Math.min(sliderY + sliderHeight, event.y));
                        const colorIndex = (sliderY + sliderHeight - dragY) / sliderHeight;
                        
                        // Generate new color based on drag position color location on slider
                        // Here we interpolate based on actual color distribution on slider
                        if (i === 0) {
                            // First color: color interpolation from slider bottom to first threshold position
                            const newColor = d3.interpolateRgb(colors[0], colors[1])(colorIndex);
                            colors[i] = newColor;
                        } else if (i === colors.length - 1) {
                            // Last color: color interpolation from second-to-last color to slider top
                            const newColor = d3.interpolateRgb(colors[colors.length - 2], colors[colors.length - 1])(colorIndex);
                            colors[i] = newColor;
                        } else {
                            // Middle colors: interpolate between adjacent colors based on position on slider
                            const prevColor = colors[i - 1];
                            const nextColor = colors[i + 1];
                            const newColor = d3.interpolateRgb(prevColor, nextColor)(colorIndex);
                            colors[i] = newColor;
                        }
                        
                        // Update marker color
                        marker.attr("fill", colors[i]);
                        
                        // Update gradient background
                        updateGradientBackground();
                        
                        // Update color scale and map
                        updateColorScale();
                    }));
                }
            });
            
            // Add "Add Threshold" button
            const addButton = colorEditor.append("g")
                .style("cursor", "pointer")
                .on("click", function() {
                    // Get dynamic endpoint value
                    const dynamicEndpoint = getDynamicEndpoint(window.gridData || [], currentConfig.colorMapping);
                    
                    // Calculate new threshold position (at middle position, but cannot exceed dynamic endpoint)
                    const maxThreshold = Math.max(...thresholds);
                    const midPoint = Math.round(maxThreshold / 2);
                    let newThreshold = midPoint;
                    
                    // Ensure new threshold doesn't exceed dynamic endpoint
                    if (newThreshold >= dynamicEndpoint) {
                        newThreshold = Math.round(dynamicEndpoint * 0.8);
                    }
                    
                    // First sort thresholds to find correct insertion position
                    const sortedThresholds = [...thresholds, newThreshold].sort((a, b) => a - b);
                    const insertIndex = sortedThresholds.indexOf(newThreshold);
                    
                    // Generate color for new threshold: interpolate between two adjacent colors
                    let newColor;
                    if (insertIndex === 0) {
                        // If it's the smallest threshold, use first color
                        newColor = colors[0];
                    } else if (insertIndex === sortedThresholds.length - 1) {
                        // If it's the largest threshold, use last color
                        newColor = colors[colors.length - 1];
                    } else {
                        // At middle position, interpolate between two adjacent colors
                        const prevThreshold = sortedThresholds[insertIndex - 1];
                        const nextThreshold = sortedThresholds[insertIndex + 1];
                        const prevThresholdIndex = thresholds.indexOf(prevThreshold);
                        const nextThresholdIndex = thresholds.indexOf(nextThreshold);
                        
                        if (prevThresholdIndex >= 0 && nextThresholdIndex >= 0) {
                            const prevColor = colors[prevThresholdIndex];
                            const nextColor = colors[nextThresholdIndex];
                            newColor = d3.interpolateRgb(prevColor, nextColor)(0.5);
                        } else {
                            // If corresponding color cannot be found, use default color
                            newColor = colors[Math.floor(colors.length / 2)];
                        }
                    }
                    
                    // Save 0's color to ensure it won't be changed
                    const zeroColor = colors[0];
                    
                    // Insert new threshold and color at correct position
                    thresholds.splice(insertIndex, 0, newThreshold);
                    colors.splice(insertIndex, 0, newColor);
                    
                    // Ensure 0's color remains unchanged
                    if (colors[0] !== zeroColor) {
                        colors[0] = zeroColor;
                    }
                    
                    // Recreate legend and update color scale
                    updateLegendFigure();
                    updateColorScale();
                });
            
            addButton.append("circle")
                .attr("cx", sliderX + sliderWidth / 2)
                .attr("cy", sliderY + sliderHeight + 25)
                .attr("r", 6)
                .attr("fill", "#222")
                .attr("stroke", "#495057")
                .attr("stroke-width", 1);
            
            addButton.append("text")
                .attr("x", sliderX + sliderWidth / 2)
                .attr("y", sliderY + sliderHeight + 28)
                .attr("text-anchor", "middle")
                .attr("font-size", "10px")
                .attr("fill", "white")
                .text("+");
            
            // addButton.append("text")
            //     .attr("x", sliderX + sliderWidth / 2)
            //     .attr("y", sliderY + sliderHeight + 38)
            //     .attr("text-anchor", "middle")
            //     .attr("font-size", "8px")
            //     .attr("fill", "#6c757d")
            //     .text("Add");
            
            // Delete additional color edit buttons, only add color picker at both ends of slider
            
            // Add function to update gradient background
            function updateGradientBackground() {
                // Clear old gradient definitions
                d3.select("#colorGradient").remove();
                
                // Create new gradient definitions
                const newGradient = colorEditor.append("defs")
                    .append("linearGradient")
                    .attr("id", "colorGradient")
                    .attr("x1", "0%")
                    .attr("y1", "100%")
                    .attr("x2", "0%")
                    .attr("y2", "0%");
                
                // Add gradient stop points
                colors.forEach((color, i) => {
                    const offset = (i / (colors.length - 1)) * 100;
                    newGradient.append("stop")
                        .attr("offset", offset + "%")
                        .attr("stop-color", color);
                });
                
                // Update gradient slider
                gradientSlider.attr("fill", "url(#colorGradient)");
            }
                }
        
        // Update color scale and re-render map
        function updateColorScale() {
            // Regenerate color scale
            const colorScale = createColorScale(window.gridData || []);
            
            // Update all circle colors (scatter mode)
            d3.selectAll(".cell-clickable circle").each(function() {
                const circle = d3.select(this);
                const cellGroup = d3.select(this.parentNode);
                const cellId = cellGroup.attr("data-cell-id");
                
                // Find corresponding cell data
                const cell = (window.gridData || []).find(d => `${d.longitude}-${d.latitude}` === cellId);
                if (cell) {
                    // Get urbanCircles information from cellGroup
                    const cellData = cellGroup.datum();
                    const urbanCircles = cellData ? cellData.urbanCircles : 0;
                    const isUrban = circle.datum() ? circle.datum().spiralIndex < urbanCircles : false;
                    const value = calculateValue(cell, isUrban);
                    const safeValue = isFinite(value) && value >= 0 ? value : 0;
                    circle.attr("fill", colorScale(safeValue));
                }
            });
            
            // Update all rectangle colors (rect mode)
            d3.selectAll(".cell-clickable rect[width]").each(function() {
                const rect = d3.select(this);
                const cellGroup = d3.select(this.parentNode);
                const cellId = cellGroup.attr("data-cell-id");
                
                // Find corresponding cell data
                const cell = (window.gridData || []).find(d => `${d.longitude}-${d.latitude}` === cellId);
                if (cell) {
                    // Get urbanAreaRatio information from cellGroup
                    const cellData = cellGroup.datum();
                    const urbanAreaRatio = cellData ? cellData.urbanAreaRatio : 0;
                    
                    // Determine if it's outer or inner rectangle
                    // We determine by checking if the rectangle is a transparent click area
                    const isClickArea = rect.attr("fill") === "transparent";
                    if (isClickArea) return; // Skip transparent click area
                    
                    // Determine based on rectangle order in cellGroup
                    // First rectangle is outer (rural), second is inner (urban)
                    const rects = cellGroup.selectAll("rect[width]").nodes();
                    const rectIndex = rects.indexOf(rect);
                    const isUrban = rectIndex === 1; // Second rectangle is inner
                    
                    const value = calculateValue(cell, isUrban);
                    const safeValue = isFinite(value) && value >= 0 ? value : 0;
                    rect.attr("fill", colorScale(safeValue));
                }
            });
            
            // Update all concentric circle colors (concentric mode)
            d3.selectAll(".cell-clickable circle[fill]").each(function() {
                const circle = d3.select(this);
                const cellGroup = d3.select(this.parentNode);
                const cellId = cellGroup.attr("data-cell-id");
                
                // Find corresponding cell data
                const cell = (window.gridData || []).find(d => `${d.longitude}-${d.latitude}` === cellId);
                if (cell) {
                    // Get urbanAreaRatio information from cellGroup
                    const cellData = cellGroup.datum();
                    const urbanAreaRatio = cellData ? cellData.urbanAreaRatio : 0;
                    
                    // Determine if it's outer or inner circle
                    // We determine by checking if the circle is a transparent click area
                    const isClickArea = circle.attr("fill") === "transparent";
                    if (isClickArea) return; // Skip transparent click area
                    
                    // Determine based on circle order in cellGroup
                    // First circle is outer (rural), second is inner (urban)
                    const circles = cellGroup.selectAll("circle[fill]").nodes();
                    const circleIndex = circles.indexOf(circle);
                    const isUrban = circleIndex === 1; // Second circle is inner
                    
                    const value = calculateValue(cell, isUrban);
                    const safeValue = isFinite(value) && value >= 0 ? value : 0;
                    circle.attr("fill", colorScale(safeValue));
                }
            });
            
            // Recreate legend
            const svg = d3.select("#chart svg");
            const maxValue = Math.max(...(window.gridData || []).map(d => Math.max(calculateValue(d, true), calculateValue(d, false))));
            createLegend(svg, colorScale, maxValue);
            
            // Force re-render
            console.log("Color scale updated:", customColorSettings[currentConfig.colorMapping]);
        }
        
        // Create concentric circle zoom view
        function createConcentricZoomView(svg, cell, colorScale, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Calculate concentric circle size
            const areaSize = Math.min(width, height) * 0.6;
            const radius = currentConfig.gridSize === '100' ? areaSize * 0.5 : areaSize * 0.5;
            
            // Calculate urban area ratio (for inner circle size)
            const totalArea = cell.urban_area + cell.rural_area;
            let urbanAreaRatio;
            if (currentConfig.useRealArea) {
                // Use real area ratio
                urbanAreaRatio = totalArea > 0 ? cell.urban_area / totalArea : 0;
            } else {
                // Use fixed area mode: inner circle occupies 20% of the area
                urbanAreaRatio = 0.2;
            }
            const innerRadius = radius * Math.sqrt(urbanAreaRatio); // Inner circle radius
            
            // Draw outer circle (representing rural population)
            const ruralValue = calculateValue(cell, false);
            const safeRuralValue = isFinite(ruralValue) && ruralValue >= 0 ? ruralValue : 0;
            
            svg.append("circle")
                .attr("cx", centerX)
                .attr("cy", centerY)
                .attr("r", radius)
                .attr("fill", colorScale(safeRuralValue))
                .attr("opacity", 0.8);
            
            // Draw inner circle (representing urban population)
            if (urbanAreaRatio > 0) {
                const urbanValue = calculateValue(cell, true);
                const safeUrbanValue = isFinite(urbanValue) && urbanValue >= 0 ? urbanValue : 0;
                
                svg.append("circle")
                    .attr("cx", centerX)
                    .attr("cy", centerY)
                    .attr("r", innerRadius)
                    .attr("fill", colorScale(safeUrbanValue))
                    .attr("opacity", 0.9);
            }
            
            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 20)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Zoomed Cell View");
        }

        // Create rectangle zoom view
        function createRectZoomView(svg, cell, colorScale, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Calculate rectangle size
            const areaSize = Math.min(width, height) * 0.6;
            const rectSize = currentConfig.gridSize === '100' ? 
                areaSize * 1 : areaSize * 1;
            
            // Calculate urban area ratio (for inner rectangle size)
                const totalArea = cell.urban_area + cell.rural_area;
                let urbanAreaRatio;
                if (currentConfig.useRealArea) {
                    // Use real area ratio
                    urbanAreaRatio = totalArea > 0 ? cell.urban_area / totalArea : 0;
                } else {
                    // Use fixed area mode: inner rectangle occupies 20% of the area
                    urbanAreaRatio = 0.2;
                }
                const innerRectSize = rectSize * Math.sqrt(urbanAreaRatio); // Inner rectangle size
            
            // Draw outer rectangle (representing rural population)
            const ruralValue = calculateValue(cell, false);
            const safeRuralValue = isFinite(ruralValue) && ruralValue >= 0 ? ruralValue : 0;
            
            svg.append("rect")
                .attr("x", centerX - rectSize/2)
                .attr("y", centerY - rectSize/2)
                .attr("width", rectSize)
                .attr("height", rectSize)
                .attr("fill", colorScale(safeRuralValue))
                .attr("opacity", 0.8);
            
            // Draw inner rectangle (representing urban population)
            if (urbanAreaRatio > 0) {
                const urbanValue = calculateValue(cell, true);
                const safeUrbanValue = isFinite(urbanValue) && urbanValue >= 0 ? urbanValue : 0;
                
                svg.append("rect")
                    .attr("x", centerX - innerRectSize/2)
                    .attr("y", centerY - innerRectSize/2)
                    .attr("width", innerRectSize)
                    .attr("height", innerRectSize)
                    .attr("fill", colorScale(safeUrbanValue))
                    .attr("opacity", 0.9);
            }
            
            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 20)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Zoomed Cell View");
        }
        
        // Create zoomed view
        function createZoomView(container, cell, circleCount, urbanCircles, ruralCircles) {
            // Clear existing content
            container.innerHTML = '';
            
            const width = container.clientWidth || 350;
            const height = 180;
            
            const svg = d3.select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Create color scale
            const colorScale = createColorScale([cell]);
            
            // Select drawing method based on visualization mode
            if (currentConfig.visualizationMode === 'concentric') {
                // Concentric circle mode
                createConcentricZoomView(svg, cell, colorScale, width, height);
            } else if (currentConfig.visualizationMode === 'rect') {
                // Rectangle mode
                createRectZoomView(svg, cell, colorScale, width, height);
            } else {
                // Scatter plot mode (original logic)
            
            // Calculate circle positions - use same parameters as main view but scale proportionally
            const centerX = width / 2;
            const centerY = height / 2;
            // Adjust zoom factor based on grid size
            const zoomFactor = currentConfig.gridSize === '1000' ? 1 : 2.5;
            const areaSize = Math.min(width, height) * 0.6;
            
            // Use same generation function as main view, but adjust parameters
            const gridSize = Math.ceil(Math.sqrt(circleCount));
            const circleRadius = (areaSize / gridSize) * currentConfig.circleSize * zoomFactor;
            const spacing = (areaSize / gridSize) * currentConfig.circleSpacing * zoomFactor;
            
            const allPositions = [];
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x = centerX - areaSize/2 + (j + 0.5) * spacing;
                    const y = centerY - areaSize/2 + (i + 0.5) * spacing;
                    allPositions.push({ x, y, i, j });
                }
            }
            
            const centerI = Math.floor(gridSize / 2);
            const centerJ = Math.floor(gridSize / 2);
            allPositions.sort((a, b) => {
                const distA = Math.sqrt((a.i - centerI) ** 2 + (a.j - centerJ) ** 2);
                const distB = Math.sqrt((b.i - centerI) ** 2 + (b.j - centerJ) ** 2);
                return distA - distB;
            });
            
            // Draw circles
            for (let idx = 0; idx < circleCount; idx++) {
                const pos = allPositions[idx];
                const isUrban = idx < urbanCircles;
                const value = calculateValue(cell, isUrban);
                const safeValue = isFinite(value) && value >= 0 ? value : 0;
                
                svg.append("circle")
                    .attr("cx", pos.x)
                    .attr("cy", pos.y)
                    .attr("r", circleRadius)
                    .attr("fill", colorScale(safeValue))
                    .attr("opacity", 0.9);
            }
            
            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 20)
                .attr("text-anchor", "middle")
                .attr("font-size", "14px")
                .attr("font-weight", "bold")
                .attr("fill", "#333")
                .text("Zoomed Cell View");
            }
        }
        
        // Show detail panel
        function showDetailPanel(cell, circleCount, urbanCircles, ruralCircles) {
            const panel = document.getElementById('detailPanel');
            const title = document.getElementById('detailPanelTitle');
            const grid = document.getElementById('detailPanelGrid');
            const chartContainer = document.getElementById('detailPanelChartContainer');
            const zoomView = document.getElementById('zoomView');
            
            // Save currently displayed cell data
            currentDetailCell = cell;
            
            // Set title
            title.textContent = `Cell Details`;
            
            // Calculate values
            const urbanValue = calculateValue(cell, true);
            const ruralValue = calculateValue(cell, false);
            const valueUnit = currentConfig.colorMapping === 'population' ? '' : '/km²';
            
            // Create zoom view
            createZoomView(zoomView, cell, circleCount, urbanCircles, ruralCircles);
            
            // Fill detailed information
            grid.innerHTML = `
                <div class="detail-panel-section">
                    <h3>Geographic Information</h3>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Longitude:</span>
                        <span class="detail-panel-value">${cell.longitude.toFixed(4)}°</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Latitude:</span>
                        <span class="detail-panel-value">${cell.latitude.toFixed(4)}°</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Grid Size:</span>
                        <span class="detail-panel-value">${currentConfig.gridSize}km</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Total Circles:</span>
                        <span class="detail-panel-value">${circleCount}</span>
                    </div>
                </div>
                
                <div class="detail-panel-section">
                    <h3>Population Data</h3>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Total Population:</span>
                        <span class="detail-panel-value">${Math.round(cell.total_population).toLocaleString()}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Urban Population:</span>
                        <span class="detail-panel-value">${Math.round(cell.urban_population).toLocaleString()}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Rural Population:</span>
                        <span class="detail-panel-value">${Math.round(cell.rural_population).toLocaleString()}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Urban Share:</span>
                        <span class="detail-panel-value">${((cell.urban_population / cell.total_population) * 100).toFixed(1)}%</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Rural Share:</span>
                        <span class="detail-panel-value">${((cell.rural_population / cell.total_population) * 100).toFixed(1)}%</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Urban Density:</span>
                        <span class="detail-panel-value">${cell.urban_area > 0 ? (cell.urban_population / cell.urban_area).toFixed(0) : '0'} /km²</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Rural Density:</span>
                        <span class="detail-panel-value">${cell.rural_area > 0 ? (cell.rural_population / cell.rural_area).toFixed(0) : '0'} /km²</span>
                    </div>
                    
                    <div class="detail-panel-chart">
                        <h4>Population Distribution</h4>
                        <div id="detailPanelChartContainer"></div>
                    </div>
                    
                    <div class="detail-panel-chart">
                        <h4>Density Distribution</h4>
                        <div id="detailPanelDensityChartContainer"></div>
                    </div>
                </div>
                
                <div class="detail-panel-section">
                    <h3>Area Information</h3>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Urban Area:</span>
                        <span class="detail-panel-value">${cell.urban_area.toFixed(1)} km²</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Rural Area:</span>
                        <span class="detail-panel-value">${cell.rural_area.toFixed(1)} km²</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Total Area:</span>
                        <span class="detail-panel-value">${(cell.urban_area + cell.rural_area).toFixed(1)} km²</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Urban Area Share:</span>
                        <span class="detail-panel-value">${((cell.urban_area / (cell.urban_area + cell.rural_area)) * 100).toFixed(1)}%</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Rural Area Share:</span>
                        <span class="detail-panel-value">${((cell.rural_area / (cell.urban_area + cell.rural_area)) * 100).toFixed(1)}%</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Urban Circles:</span>
                        <span class="detail-panel-value">${urbanCircles}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Rural Circles:</span>
                        <span class="detail-panel-value">${ruralCircles}</span>
                    </div>
                    
                    <div class="detail-panel-chart">
                        <h4>Area Distribution</h4>
                        <div id="detailPanelAreaChartContainer"></div>
                    </div>
                </div>
                
                <div class="detail-panel-section">
                    <h3>Visualization Settings</h3>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Circle Size:</span>
                        <span class="detail-panel-value">${currentConfig.circleSize}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Circle Spacing:</span>
                        <span class="detail-panel-value">${currentConfig.circleSpacing}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Max Circles:</span>
                        <span class="detail-panel-value">${currentConfig.maxCircles}</span>
                    </div>
                    <div class="detail-panel-item">
                        <span class="detail-panel-label">Area Data:</span>
                        <span class="detail-panel-value">${currentConfig.useRealArea ? 'Real Area' : 'Fixed Area'}</span>
                    </div>
                </div>
            `;
            
            // Create population distribution chart
            const colorScale = createColorScale([cell]);
            createDetailChart(document.getElementById('detailPanelChartContainer'), cell, urbanCircles, ruralCircles, colorScale);
            
            // Create population density chart
            createDensityChart(document.getElementById('detailPanelDensityChartContainer'), cell, colorScale);
            
            // Create area distribution chart
            createAreaChart(document.getElementById('detailPanelAreaChartContainer'), cell, colorScale);
            
            // Show panel
            panel.style.display = 'flex';
            setTimeout(() => {
                panel.classList.add('show');
                // Update zoom controls position after panel is fully shown
                updateZoomControlsPosition();
            }, 10);
        }
        
        // Create detail chart
        function createDetailChart(container, cell, urbanCircles, ruralCircles, colorScale) {
            // Clear existing content
            container.innerHTML = '';
            
            // Get container's actual available width, minus padding
            const containerRect = container.getBoundingClientRect();
            const width = Math.max(containerRect.width - 30, 300); // Min 300px, minus padding
            const height = 200;
            
            const svg = d3.select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .style("max-width", "100%")
                .style("overflow", "visible");
            
            // Data - use actual population data, unaffected by circle settings, rounded to integers, use current Cell's color allocation
            const data = [
                { name: 'Urban', value: Math.round(cell.urban_population), color: colorScale(calculateValue(cell, true)) },
                { name: 'Rural', value: Math.round(cell.rural_population), color: colorScale(calculateValue(cell, false)) }
            ];
            
            // Scale
            const x = d3.scaleBand()
                .domain(data.map(d => d.name))
                .range([0, width])
                .padding(0.1);
            
            const y = d3.scaleLinear()
                .domain([0, Math.max(data[0].value, data[1].value)])
                .range([height - 40, 40]);
            
            // Draw bar chart
            svg.selectAll("rect")
                .data(data)
                .enter()
                .append("rect")
                .attr("x", d => x(d.name))
                .attr("y", d => y(d.value))
                .attr("width", x.bandwidth())
                .attr("height", d => height - 40 - y(d.value))
                .attr("fill", d => d.color)
                .attr("opacity", 0.8);
            
            // Add value labels
            svg.selectAll("text")
                .data(data)
                .enter()
                .append("text")
                .attr("x", d => x(d.name) + x.bandwidth() / 2)
                .attr("y", d => y(d.value) - 5)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("fill", "#333")
                .text(d => `${d.value.toLocaleString()}`);
            
            // Add x-axis labels
            svg.selectAll(".x-label")
                .data(data)
                .enter()
                .append("text")
                .attr("class", "x-label")
                .attr("x", d => x(d.name) + x.bandwidth() / 2)
                .attr("y", height - 5)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("fill", "#333")
                .text(d => d.name);
            
            // // Add title
            // svg.append("text")
            //     .attr("x", width / 2)
            //     .attr("y", 20)
            //     .attr("text-anchor", "middle")
            //     .attr("font-size", "14px")
            //     .attr("font-weight", "bold")
            //     .text("Population Distribution");
        }
        
        // Create area distribution pie chart
        function createAreaChart(container, cell, colorScale) {
            // Clear existing content
            container.innerHTML = '';
            
            // Get container's actual available width, minus padding
            const containerRect = container.getBoundingClientRect();
            const width = Math.max(containerRect.width - 30, 300); // Min 300px, minus padding
            const height = 200;
            
            const svg = d3.select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .style("max-width", "100%")
                .style("overflow", "visible");
            
            // Data - area data rounded to integers, use current Cell's color allocation
            const data = [
                { name: 'Urban Area', value: Math.round(cell.urban_area), color: colorScale(calculateValue(cell, true)) },
                { name: 'Rural Area', value: Math.round(cell.rural_area), color: colorScale(calculateValue(cell, false)) }
            ].filter(d => d.value > 0); // Only show areas with area data
            
            if (data.length === 0) {
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", height / 2)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .attr("fill", "#666")
                    .text("No area data available");
                return;
            }
            
            // Create pie chart
            const radius = Math.min(width, height) / 3;
            const centerX = width / 2;
            const centerY = height / 2;
            
            const pie = d3.pie()
                .value(d => d.value)
                .sort(null);
            
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius);
            
            // Draw pie slices
            const pieGroup = svg.append("g")
                .attr("transform", `translate(${centerX}, ${centerY})`);
            
            pieGroup.selectAll("path")
                .data(pie(data))
                .enter()
                .append("path")
                .attr("d", arc)
                .attr("fill", d => d.data.color)
                .attr("opacity", 0.8)
                .attr("stroke", "#fff")
                .attr("stroke-width", 2);
            
            // Add labels
            pieGroup.selectAll("text")
                .data(pie(data))
                .enter()
                .append("text")
                .attr("transform", d => `translate(${arc.centroid(d)})`)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("fill", "#fff")
                .attr("font-weight", "bold")
                .text(d => `${((d.data.value / (Math.round(cell.urban_area) + Math.round(cell.rural_area))) * 100).toFixed(1)}%`);
            
            // Add legend
            const legend = svg.append("g")
                .attr("transform", `translate(${width - 100}, 20)`);
            
            data.forEach((d, i) => {
                const legendItem = legend.append("g")
                    .attr("transform", `translate(0, ${i * 20})`);
                
                legendItem.append("rect")
                    .attr("width", 12)
                    .attr("height", 12)
                    .attr("fill", d.color);
                
                legendItem.append("text")
                    .attr("x", 18)
                    .attr("y", 9)
                    .attr("font-size", "11px")
                    .text(d.name);
            });
        }
        
        // Create population density chart
        function createDensityChart(container, cell, colorScale) {
            // Clear existing content
            container.innerHTML = '';
            
            // Get container's actual available width, minus padding
            const containerRect = container.getBoundingClientRect();
            const width = Math.max(containerRect.width - 30, 300); // Minus padding, minimum 300px
            const height = 200;
            
            const svg = d3.select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .style("max-width", "100%")
                .style("overflow", "visible");
            
            // Calculate density data
            const urbanDensity = cell.urban_area > 0 ? cell.urban_population / cell.urban_area : 0;
            const ruralDensity = cell.rural_area > 0 ? cell.rural_population / cell.rural_area : 0;
            
            const data = [
                { name: 'Urban', value: Math.round(urbanDensity), color: colorScale(calculateValue(cell, true)) },
                { name: 'Rural', value: Math.round(ruralDensity), color: colorScale(calculateValue(cell, false)) }
            ].filter(d => d.value > 0); // Only show areas with density data
            
            if (data.length === 0) {
                svg.append("text")
                    .attr("x", width / 2)
                    .attr("y", height / 2)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "14px")
                    .attr("fill", "#666")
                    .text("No density data available");
                return;
            }
            
            // Scale
            const x = d3.scaleBand()
                .domain(data.map(d => d.name))
                .range([0, width])
                .padding(0.1);
            
            const y = d3.scaleLinear()
                .domain([0, Math.max(...data.map(d => d.value))])
                .range([height - 40, 40]);
            
            // Draw bar chart
            svg.selectAll("rect")
                .data(data)
                .enter()
                .append("rect")
                .attr("x", d => x(d.name))
                .attr("y", d => y(d.value))
                .attr("width", x.bandwidth())
                .attr("height", d => height - 40 - y(d.value))
                .attr("fill", d => d.color)
                .attr("opacity", 0.8);
            
            // Add value labels
            svg.selectAll("text")
                .data(data)
                .enter()
                .append("text")
                .attr("x", d => x(d.name) + x.bandwidth() / 2)
                .attr("y", d => y(d.value) - 5)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("fill", "#333")
                .text(d => `${d.value.toLocaleString()} /km²`);
            
            // Add x-axis labels
            svg.selectAll(".x-label")
                .data(data)
                .enter()
                .append("text")
                .attr("class", "x-label")
                .attr("x", d => x(d.name) + x.bandwidth() / 2)
                .attr("y", height - 5)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .attr("fill", "#333")
                .text(d => d.name);
        }
        
        // Close detail panel
        function closeDetailPanel() {
            const panel = document.getElementById('detailPanel');
            
            // Clear selection state
            d3.selectAll(".cell-clickable").classed("selected", false);
            
            // Clear currently displayed cell data
            currentDetailCell = null;
            
            // Move zoom controls back to original position
            const zoomControls = document.querySelector('.zoom-controls');
            if (zoomControls) {
                zoomControls.classList.remove('with-details');
            }
            
            panel.classList.remove('show');
            setTimeout(() => {
                panel.style.display = 'none';
                // Update zoom controls position after panel is fully hidden
                updateZoomControlsPosition();
            }, 300);
        }
        
        // Function to update zoom controls position based on detail panel state
        function updateZoomControlsPosition() {
            const zoomControls = document.querySelector('.zoom-controls');
            const detailPanel = document.getElementById('detailPanel');
            
            if (zoomControls && detailPanel) {
                // Check if detail panel is visible and its width
                const isVisible = detailPanel.classList.contains('show');
                const panelWidth = detailPanel.offsetWidth;
                const isFullscreen = panelWidth >= window.innerWidth * 0.9; // Consider fullscreen if width > 90% of window
                
                if (isVisible && !isFullscreen) {
                    // Detail panel is visible but not fullscreen - move zoom controls to the left
                    zoomControls.classList.add('with-details');
                } else {
                    // Detail panel is hidden or fullscreen - keep zoom controls in original position
                    zoomControls.classList.remove('with-details');
                }
            }
        }
        
        // Resize charts
        function resizeDetailCharts() {
            const chartContainer = document.getElementById('detailPanelChartContainer');
            const densityChartContainer = document.getElementById('detailPanelDensityChartContainer');
            const areaChartContainer = document.getElementById('detailPanelAreaChartContainer');
            
            if (chartContainer && chartContainer.innerHTML && currentDetailCell) {
                // Recreate chart to adjust size
                const urbanCircles = Math.round(currentDetailCell.urban_area / (currentConfig.circleSize * currentConfig.circleSize));
                const ruralCircles = Math.round(currentDetailCell.rural_area / (currentConfig.circleSize * currentConfig.circleSize));
                createDetailChart(chartContainer, currentDetailCell, urbanCircles, ruralCircles, colorScale);
            }
            
            if (densityChartContainer && densityChartContainer.innerHTML && currentDetailCell) {
                createDensityChart(densityChartContainer, currentDetailCell, colorScale);
            }
            
            if (areaChartContainer && areaChartContainer.innerHTML && currentDetailCell) {
                createAreaChart(areaChartContainer, currentDetailCell, colorScale);
            }
        }
        
        // Initialize chart
        function initChart() {
            const { width, height, areaSize } = getResponsiveDimensions();
            
            // Use maxCircles from currentConfig
            MAPPING_CONFIG.maxCircles = currentConfig.maxCircles;
            
            // Clear existing content but keep zoom control buttons
            const zoomControls = document.querySelector('.zoom-controls');
            
            // Save zoom button HTML content
            const zoomControlsHTML = zoomControls ? zoomControls.innerHTML : '';
            
            d3.select("#chart").selectAll("*").remove();
            
            // Recreate zoom control buttons
            if (zoomControlsHTML) {
                const newZoomControls = document.createElement('div');
                newZoomControls.className = 'zoom-controls';
                newZoomControls.innerHTML = zoomControlsHTML;
                document.getElementById('chart').appendChild(newZoomControls);
            }

            const svg = d3.select("#chart")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet");

            // Create zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([MIN_ZOOM, MAX_ZOOM])
                .on("zoom", function(event) {
                    currentZoom = event.transform;
                    zoomLevel = event.transform.k;
                    
                    // Apply zoom transform to map group
                    svg.select(".map-group").attr("transform", event.transform);
                    
                    // Delay updating zoom info to avoid errors during initialization
                    setTimeout(() => {
                        updateZoomInfo();
                    }, 0);
                })
                .on("end", function(event) {
                    // Double-click zoom function preserved, but doesn't reset to initial position
                    if (event.sourceEvent && event.sourceEvent.type === "dblclick") {
                        // Zoom in on double-click, not reset
                        const currentTransform = d3.zoomTransform(svg.node());
                        const newScale = Math.min(MAX_ZOOM, currentTransform.k * 1.5);
                        
                        if (newScale > currentTransform.k) {
                            // Get double-click position relative to SVG coordinates
                            const rect = svg.node().getBoundingClientRect();
                            const x = event.sourceEvent.clientX - rect.left;
                            const y = event.sourceEvent.clientY - rect.top;
                            
                            // Use D3.js zoom.scaleTo method for smooth zoom centered on double-click position
                            const point = [x, y];
                            svg.call(zoom.scaleTo, newScale, point);
                            
                            // Update global zoom state
                            currentZoom = d3.zoomTransform(svg.node());
                            zoomLevel = newScale;
                            updateZoomInfo();
                        }
                    }
                });

            // Apply zoom behavior to SVG
            svg.call(zoom);

            const tooltip = d3.select(".chart-container")
                .append("div")
                .attr("class", "tooltip");

            // Responsive projection
            const projection = d3.geoMercator()
                .center([10, -15])
                .scale(Math.min(width, height) / 1.5)
                .translate([width / 2, height / 2]);

            const path = d3.geoPath().projection(projection);

            // Create map group
            const mapGroup = svg.append("g")
                .attr("class", "map-group");

            // Load data
            const dataFile = currentConfig.gridSize === '100' 
                ? "data/aggregated_100km_africa.json" 
                : "data/aggregated_1000km_africa.json";

            Promise.all([
                d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"),
                d3.json(dataFile)
            ]).then(([geojson, data]) => {
                const gridData = Object.values(data.grid_data)
                    .map(d => {
                        const rawLon = d.geographic_location.longitude;
                        const rawLat = d.geographic_location.latitude;
                        const correctedLon = -rawLat;
                        const correctedLat = -rawLon;

                        return {
                            ...d,
                            total_population: d.rural_population + d.urban_population,
                            longitude: correctedLon,
                            latitude: correctedLat
                        };
                    })
                    // Remove filter conditions, show all grids (including grids with 0 population)
                    // .filter(d => d.total_population > 0);

                // Save to global variable
                window.gridData = gridData;

                // Calculate statistics
                const populations = gridData.map(d => d.total_population);
                const minPop = Math.min(...populations);
                const maxPop = Math.max(...populations);

                // Background map
                mapGroup.append("g")
                    .selectAll("path")
                    .data(geojson.features.filter(d => d.properties.continent === "Africa"))
                    .enter()
                    .append("path")
                    .attr("d", path)
                    .attr("fill", "#f0f0f0")
                    .attr("stroke", "#999")
                    .attr("stroke-width", Math.max(0.3, width / 1000));

                // create color scale
                const colorScale = createColorScale(gridData);
                
                // according to visualization mode, choose the corresponding drawing method
                if (currentConfig.visualizationMode === 'concentric') {
                    // Use concentric circle mode
                    createConcentricCircles(svg, gridData, colorScale, areaSize);
                    
                    // create legend
                    const maxValue = Math.max(...gridData.map(d => Math.max(calculateValue(d, true), calculateValue(d, false))));
                    createLegend(svg, colorScale, maxValue);
                } else if (currentConfig.visualizationMode === 'rect') {
                    // Use rectangle mode
                    createRectangles(svg, gridData, colorScale, areaSize);
                    
                    // create legend
                    const maxValue = Math.max(...gridData.map(d => Math.max(calculateValue(d, true), calculateValue(d, false))));
                    createLegend(svg, colorScale, maxValue);
                } else {
                    // Use scatter plot mode (original logic)
                    gridData.forEach(cell => {
                    const projectedPos = projection([cell.longitude, cell.latitude]);
                    if (!projectedPos) return;

                    const circleCount = calculateCircleCount(cell.total_population, minPop, maxPop);
                    const positions = generateCirclePositionsInFixedArea(circleCount, projectedPos[0], projectedPos[1], areaSize);

                    // Calculate urban-rural circle count
                    let urbanCircles, ruralCircles;
                    
                    if (currentConfig.useRealArea) {
                        const cellTotalArea = cell.rural_area + cell.urban_area;
                        if (cellTotalArea > 0) {
                            const urbanRatio = cell.urban_area / cellTotalArea;
                            const ruralRatio = cell.rural_area / cellTotalArea;
                            urbanCircles = Math.round(circleCount * urbanRatio);
                            ruralCircles = circleCount - urbanCircles;
                        } else {
                            // Use fixed area mode: inner circle occupies 20% of count
                            urbanCircles = Math.round(circleCount * MAPPING_CONFIG.urbanAreaShare);
                            ruralCircles = circleCount - urbanCircles;
                        }
                    } else {
                        urbanCircles = Math.round(circleCount * MAPPING_CONFIG.urbanAreaShare);
                        ruralCircles = circleCount - urbanCircles;
                    }

                    // create grid cell group
                    const cellGroup = svg.select(".map-group").append("g")
                        .attr("class", "cell-clickable")
                        .attr("data-cell-id", `${cell.longitude}-${cell.latitude}`)
                        .datum({ urbanCircles: urbanCircles, ruralCircles: ruralCircles })
                        .on("click", function(event) {
                            // remove the highlight of the previously selected cell
                            d3.selectAll(".cell-clickable").classed("selected", false);
                            
                            // add selected state to the current cell
                            d3.select(this).classed("selected", true);
                            
                            // show detailed information
                            showDetailPanel(cell, circleCount, urbanCircles, ruralCircles);
                        });

                    // add transparent click area
                    const clickSize = areaSize * 1.5; // Larger click area
                    cellGroup.append("rect")
                        .attr("x", projectedPos[0] - clickSize/2)
                        .attr("y", projectedPos[1] - clickSize/2)
                        .attr("width", clickSize)
                        .attr("height", clickSize)
                        .attr("fill", "transparent")
                        .style("pointer-events", "all");

                    // draw circles
                    positions.forEach((pos, index) => {
                        const isUrban = pos.spiralIndex < urbanCircles;
                        const value = calculateValue(cell, isUrban);
                        const safeValue = isFinite(value) && value >= 0 ? value : 0;
                        
                        cellGroup.append("circle")
                            .attr("cx", pos.x)
                            .attr("cy", pos.y)
                            .attr("r", pos.radius)
                            .attr("fill", colorScale(safeValue))
                            .attr("opacity", 0.8)
                            .on("mouseover", function(event) {
                                const urbanValue = calculateValue(cell, true);
                                const ruralValue = calculateValue(cell, false);
                                const valueUnit = currentConfig.colorMapping === 'population' ? '' : '/km²';
                                
                                tooltip.transition()
                                    .duration(200)
                                    .style("opacity", .9);
                                tooltip.html(`
                                    <strong>Cell Info:</strong><br>
                                    <strong>Lon:</strong> ${cell.longitude.toFixed(2)}°, 
                                    <strong>Lat:</strong> ${cell.latitude.toFixed(2)}°<br>
                                    <strong>Total Population:</strong> ${Math.round(cell.total_population).toLocaleString()}<br>
                                    <strong>Circles:</strong> ${circleCount} (${urbanCircles} urban, ${ruralCircles} rural)<br>
                                    <strong>Urban:</strong> ${Math.round(cell.urban_population).toLocaleString()} (${urbanValue.toFixed(1)}${valueUnit})<br>
                                    <strong>Rural:</strong> ${Math.round(cell.rural_population).toLocaleString()} (${ruralValue.toFixed(1)}${valueUnit})<br>
                                    <strong>Urban Area:</strong> ${cell.urban_area.toFixed(1)} km²<br>
                                    <strong>Rural Area:</strong> ${cell.rural_area.toFixed(1)} km²
                                `)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 28) + "px");
                            })
                            .on("mouseout", () => {
                                tooltip.transition()
                                    .duration(500)
                                    .style("opacity", 0);
                            });
                    });
                });
                }

                // create legend
                const maxValue = Math.max(...gridData.map(d => Math.max(calculateValue(d, true), calculateValue(d, false))));
                
                createLegend(svg, colorScale, maxValue);
                
                // Update continuous color slider in legend
                updateLegendFigure();
                
                // rebind zoom button event listener
                const resetZoomBtn = document.getElementById('resetZoomBtn');
                
                // remove old event listener, avoid duplicate binding
                if (resetZoomBtn) {
                    resetZoomBtn.removeEventListener('click', resetZoom);
                    resetZoomBtn.addEventListener('click', resetZoom);
                }
                
                // update zoom info
                updateZoomInfo();
            });
        }
        
        // Create concentric circle visualization
        function createConcentricCircles(svg, gridData, colorScale, areaSize) {
            // clear existing content
            svg.select(".map-group").selectAll(".cell-clickable").remove();
            
            const tooltip = d3.select(".chart-container .tooltip");
            
            // responsive projection
            const width = svg.attr("width");
            const height = svg.attr("height");
            const projection = d3.geoMercator()
                .center([10, -15])
                .scale(Math.min(width, height) / 1.5)
                .translate([width / 2, height / 2]);

            // Create concentric circles for each grid
            gridData.forEach(cell => {
                const projectedPos = projection([cell.longitude, cell.latitude]);
                if (!projectedPos) return;

                // Calculate circle size (based on total population)
                const populations = gridData.map(d => d.total_population);
                const minPop = Math.min(...populations);
                const maxPop = Math.max(...populations);
                const circleCount = calculateCircleCount(cell.total_population, minPop, maxPop);
                
                // calculate the size of concentric circles
                // const radius = currentConfig.gridSize === '100' ? areaSize * 0.2 : areaSize * 0.5;
                const radius = currentConfig.gridSize === '100' ? (areaSize / currentConfig.gridSize) * currentConfig.circleSize * 100 : (areaSize / currentConfig.gridSize) * currentConfig.circleSize * 1000;
                
                // calculate the ratio of urban area (for inner circle size)
                const totalArea = cell.urban_area + cell.rural_area;
                let urbanAreaRatio;
                if (currentConfig.useRealArea) {
                    // use real area ratio
                    urbanAreaRatio = totalArea > 0 ? cell.urban_area / totalArea : 0;
                } else {
                    // use fixed area mode: inner circle occupies 20% of the area
                    urbanAreaRatio = 0.2;
                }
                const innerRadius = radius * Math.sqrt(urbanAreaRatio); // inner circle radius
                
                // create grid cell group
                const cellGroup = svg.select(".map-group").append("g")
                    .attr("class", "cell-clickable")
                    .attr("data-cell-id", `${cell.longitude}-${cell.latitude}`)
                    .datum({ urbanAreaRatio: urbanAreaRatio, totalPopulation: cell.total_population })
                    .on("click", function(event) {
                        // remove the highlight of the previously selected cell
                        d3.selectAll(".cell-clickable").classed("selected", false);
                        
                        // add selected state to the current cell
                        d3.select(this).classed("selected", true);
                        
                        // show detailed information
                        showDetailPanel(cell, 1, 1, 0); // simplified parameters
                    });

                // add transparent click area
                const clickSize = radius * 2;
                cellGroup.append("rect")
                    .attr("x", projectedPos[0] - clickSize/2)
                    .attr("y", projectedPos[1] - clickSize/2)
                    .attr("width", clickSize)
                    .attr("height", clickSize)
                    .attr("fill", "transparent")
                    .style("pointer-events", "all");

                // draw outer circle (representing rural population)
                const ruralValue = calculateValue(cell, false); // use rural value as outer circle color
                const safeRuralValue = isFinite(ruralValue) && ruralValue >= 0 ? ruralValue : 0;
                
                cellGroup.append("circle")
                    .attr("cx", projectedPos[0])
                    .attr("cy", projectedPos[1])
                    .attr("r", radius)
                    .attr("fill", colorScale(safeRuralValue))
                    .attr("opacity", 0.8)
                    .on("mouseover", function(event) {
                        const urbanValue = calculateValue(cell, true);
                        const ruralValue = calculateValue(cell, false);
                        const valueUnit = currentConfig.colorMapping === 'population' ? '' : '/km²';
                        
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        tooltip.html(`
                            <strong>Cell Info:</strong><br>
                            <strong>Lon:</strong> ${cell.longitude.toFixed(2)}°, 
                            <strong>Lat:</strong> ${cell.latitude.toFixed(2)}°<br>
                            <strong>Total Population:</strong> ${Math.round(cell.total_population).toLocaleString()}<br>
                            <strong>Rural Population:</strong> ${Math.round(cell.rural_population).toLocaleString()} (outer circle)<br>
                            <strong>Urban Population:</strong> ${Math.round(cell.urban_population).toLocaleString()} (inner circle, ${urbanAreaRatio.toFixed(1)}% area)<br>
                            <strong>Rural Value:</strong> ${ruralValue.toFixed(1)}${valueUnit}<br>
                            <strong>Urban Value:</strong> ${urbanValue.toFixed(1)}${valueUnit}<br>
                            <strong>Rural Area:</strong> ${cell.rural_area.toFixed(1)} km²<br>
                            <strong>Urban Area:</strong> ${cell.urban_area.toFixed(1)} km²
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", () => {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                // draw inner circle (representing urban population)
                if (urbanAreaRatio > 0) {
                    const urbanValue = calculateValue(cell, true); // use urban value as inner circle color
                    const safeUrbanValue = isFinite(urbanValue) && urbanValue >= 0 ? urbanValue : 0;
                    
                    cellGroup.append("circle")
                        .attr("cx", projectedPos[0])
                        .attr("cy", projectedPos[1])
                        .attr("r", innerRadius)
                        .attr("fill", colorScale(safeUrbanValue))
                        .attr("opacity", 0.9)
                        .on("mouseover", function(event) {
                            const urbanValue = calculateValue(cell, true);
                            const ruralValue = calculateValue(cell, false);
                            const valueUnit = currentConfig.colorMapping === 'population' ? '' : '/km²';
                            
                            tooltip.transition()
                                .duration(200)
                                .style("opacity", .9);
                            tooltip.html(`
                                <strong>Cell Info:</strong><br>
                                <strong>Lon:</strong> ${cell.longitude.toFixed(2)}°, 
                                <strong>Lat:</strong> ${cell.latitude.toFixed(2)}°<br>
                                <strong>Total Population:</strong> ${cell.total_population.toLocaleString()}<br>
                                <strong>Rural Population:</strong> ${cell.rural_population.toLocaleString()} (outer circle)<br>
                                <strong>Urban Population:</strong> ${cell.urban_population.toLocaleString()} (inner circle, ${urbanAreaRatio.toFixed(1)}% area)<br>
                                <strong>Rural Value:</strong> ${ruralValue.toFixed(1)}${valueUnit}<br>
                                <strong>Urban Value:</strong> ${urbanValue.toFixed(1)}${valueUnit}<br>
                                <strong>Rural Area:</strong> ${cell.rural_area.toFixed(1)} km²<br>
                                <strong>Urban Area:</strong> ${cell.urban_area.toFixed(1)} km²
                            `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", () => {
                            tooltip.transition()
                                .duration(500)
                                .style("opacity", 0);
                        });
                }
            });
            
            // rebind zoom button event listener
            const resetZoomBtn = document.getElementById('resetZoomBtn');
            
            // remove old event listener, avoid duplicate binding
            if (resetZoomBtn) {
                resetZoomBtn.removeEventListener('click', resetZoom);
                resetZoomBtn.addEventListener('click', resetZoom);
            }
            
            // update zoom info
            updateZoomInfo();
        }

        // event listener
        document.getElementById('gridSize').addEventListener('change', function() {
            currentConfig.gridSize = this.value;
            
            // update custom color settings thresholds
            if (this.value === '100') {
                customColorSettings.population.thresholds = [1000, 5000, 15000, 50000, 100000, 300000];
            } else {
                customColorSettings.population.thresholds = [100000, 500000, 1500000, 5000000, 10000000, 30000000];
            }
            
            // adjust circle parameters according to grid size
            if (this.value === '100') {
                // 100km parameters
                currentConfig.circleSize = 0.2;
                currentConfig.circleSpacing = 0.4;
                currentConfig.maxCircles = 16;
                document.getElementById('circleSize').value = 0.2;
                document.getElementById('circleSpacing').value = 0.4;
                document.getElementById('maxCircles').value = 16;
                document.getElementById('circleSizeValue').textContent = '0.2';
                document.getElementById('circleSpacingValue').textContent = '0.4';
                document.getElementById('maxCirclesValue').textContent = '16';
            } else {
                // 1000km parameters
                currentConfig.circleSize = 0.5;
                currentConfig.circleSpacing = 1.0;
                currentConfig.maxCircles = 100;
                document.getElementById('circleSize').value = 0.5;
                document.getElementById('circleSpacing').value = 1.0;
                document.getElementById('maxCircles').value = 100;
                document.getElementById('circleSizeValue').textContent = '0.5';
                document.getElementById('circleSpacingValue').textContent = '1.0';
                document.getElementById('maxCirclesValue').textContent = '100';
            }
            
            updateLegendFigure();
            initChart();
        });

        document.getElementById('areaData').addEventListener('change', function() {
            currentConfig.useRealArea = this.value === 'true';
            initChart();
        });

        document.getElementById('colorMapping').addEventListener('change', function() {
            currentConfig.colorMapping = this.value;
            initChart();
        });

        document.getElementById('circleSize').addEventListener('input', function() {
            currentConfig.circleSize = parseFloat(this.value);
            document.getElementById('circleSizeValue').textContent = this.value;
            initChart();
        });

        document.getElementById('circleSpacing').addEventListener('input', function() {
            currentConfig.circleSpacing = parseFloat(this.value);
            document.getElementById('circleSpacingValue').textContent = this.value;
            initChart();
        });

        document.getElementById('maxCircles').addEventListener('input', function() {
            currentConfig.maxCircles = parseInt(this.value);
            document.getElementById('maxCirclesValue').textContent = this.value;
            initChart();
        });

        document.getElementById('visualizationMode').addEventListener('change', function() {
            currentConfig.visualizationMode = this.value;
            updateLegendFigure();
            initChart();
        });

        // close button event listener
        document.getElementById('closeDetailPanelBtn').addEventListener('click', closeDetailPanel);
        
        // ESC key close panel
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeDetailPanel();
            }
        });

        // update legend of visualization mode
        function updateLegendFigure() {
            const figureContainer = d3.select('.figure-container');
            if (figureContainer.empty()) return;
            
            // clear existing content
            figureContainer.selectAll('*').remove();
            
            // according to current configuration, choose the corresponding legend
            const getFigurePath = () => {
                const mode = currentConfig.visualizationMode;
                const size = currentConfig.gridSize;
                
                if (mode === 'scatter') {
                    return size === '100' ? 'figures/scatter_100.svg' : 'figures/scatter_1000.svg';
                } else if (mode === 'concentric') {
                    return size === '100' ? 'figures/concentric_100.svg' : 'figures/concentric_1000.svg';
                } else if (mode === 'rect') {
                    return size === '100' ? 'figures/rect_100.svg' : 'figures/rect_1000.svg';
                }
                return 'figures/scatter_100.svg'; // default
            };

            // create legend container
            const legendFigure = figureContainer.append("foreignObject")
                .attr("x", -20)
                .attr("y", 0)
                .attr("width", 400)
                .attr("height", 150);

            // load SVG legend
            const figurePath = getFigurePath();
            fetch(figurePath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(svgContent => {
                    // create temporary div to parse SVG
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = svgContent;
                    const svgElement = tempDiv.querySelector('svg');
                    
                    if (svgElement) {
                        // adjust SVG size and style
                        svgElement.style.width = '100%';
                        svgElement.style.height = 'auto';
                        svgElement.style.maxHeight = '120px';
                        
                        // insert SVG content into foreignObject
                        legendFigure.node().appendChild(svgElement);
                    } else {
                        throw new Error('SVG element not found in response');
                    }
                })
                .catch(error => {
                    console.error('Error loading figure:', error);
                    // if loading fails, display backup text
                    figureContainer.append("text")
                        .attr("x", 0)
                        .attr("y", 35)
                        .attr("font-size", "9px")
                        .attr("fill", "#666")
                        .text("• Visualization mode: " + currentConfig.visualizationMode);
                });
            
            // only keep vertical slider, delete horizontal slider
        }

        // Create rectangle visualization
        function createRectangles(svg, gridData, colorScale, areaSize) {
            // clear existing content
            svg.select(".map-group").selectAll(".cell-clickable").remove();
            
            const tooltip = d3.select(".chart-container .tooltip");
            
            // responsive projection
            const width = svg.attr("width");
            const height = svg.attr("height");
            const projection = d3.geoMercator()
                .center([10, -15])
                .scale(Math.min(width, height) / 1.5)
                .translate([width / 2, height / 2]);

            // create rectangles for each grid
            gridData.forEach(cell => {
                const projectedPos = projection([cell.longitude, cell.latitude]);
                if (!projectedPos) return;

                // calculate the size of rectangles (based on total population)
                const populations = gridData.map(d => d.total_population);
                const minPop = Math.min(...populations);
                const maxPop = Math.max(...populations);
                const circleCount = calculateCircleCount(cell.total_population, minPop, maxPop);
                
                // calculate the size of rectangles
                const rectSize = currentConfig.gridSize === '100' ? 
                    (areaSize / currentConfig.gridSize) * currentConfig.circleSize * 100 * 2 : 
                    (areaSize / currentConfig.gridSize) * currentConfig.circleSize * 1000 * 2;
                
                // calculate the ratio of urban area (for inner rectangle size)
                const totalArea = cell.urban_area + cell.rural_area;
                let urbanAreaRatio;
                if (currentConfig.useRealArea) {
                    // use real area ratio
                    urbanAreaRatio = totalArea > 0 ? cell.urban_area / totalArea : 0;
                } else {
                    // use fixed area mode: inner rectangle occupies 20% of the area
                    urbanAreaRatio = 0.2;
                }
                const innerRectSize = rectSize * Math.sqrt(urbanAreaRatio); // inner rectangle size
                
                // create grid cell group
                const cellGroup = svg.select(".map-group").append("g")
                    .attr("class", "cell-clickable")
                    .attr("data-cell-id", `${cell.longitude}-${cell.latitude}`)
                    .datum({ urbanAreaRatio: urbanAreaRatio, totalPopulation: cell.total_population })
                    .on("click", function(event) {
                        // remove the highlight of the previously selected cell
                        d3.selectAll(".cell-clickable").classed("selected", false);
                        
                        // add selected state to the current cell
                        d3.select(this).classed("selected", true);
                        
                        // show detailed information
                        showDetailPanel(cell, 1, 1, 0); // simplified parameters
                    });

                // add transparent click area
                const clickSize = rectSize * 2;
                cellGroup.append("rect")
                    .attr("x", projectedPos[0] - clickSize/2)
                    .attr("y", projectedPos[1] - clickSize/2)
                    .attr("width", clickSize)
                    .attr("height", clickSize)
                    .attr("fill", "transparent")
                    .style("pointer-events", "all");

                // draw outer rectangle (representing rural population)
                const ruralValue = calculateValue(cell, false); // use rural value as outer rectangle color
                const safeRuralValue = isFinite(ruralValue) && ruralValue >= 0 ? ruralValue : 0;
                
                cellGroup.append("rect")
                    .attr("x", projectedPos[0] - rectSize/2)
                    .attr("y", projectedPos[1] - rectSize/2)
                    .attr("width", rectSize)
                    .attr("height", rectSize)
                    .attr("fill", colorScale(safeRuralValue))
                    .attr("opacity", 0.8)
                    .on("mouseover", function(event) {
                        const urbanValue = calculateValue(cell, true);
                        const ruralValue = calculateValue(cell, false);
                        const valueUnit = currentConfig.colorMapping === 'population' ? '' : '/km²';
                        
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        tooltip.html(`                            <strong>Cell Info:</strong><br>
                            <strong>Lon:</strong> ${cell.longitude.toFixed(2)}°, 
                            <strong>Lat:</strong> ${cell.latitude.toFixed(2)}°<br>
                            <strong>Total Population:</strong> ${Math.round(cell.total_population).toLocaleString()}<br>
                            <strong>Rural Population:</strong> ${Math.round(cell.rural_population).toLocaleString()} (outer rectangle)<br>
                            <strong>Urban Population:</strong> ${Math.round(cell.urban_population).toLocaleString()} (inner rectangle, ${urbanAreaRatio.toFixed(1)}% area)<br>
                            <strong>Rural Value:</strong> ${ruralValue.toFixed(1)}${valueUnit}<br>
                            <strong>Urban Value:</strong> ${urbanValue.toFixed(1)}${valueUnit}<br>
                            <strong>Rural Area:</strong> ${cell.rural_area.toFixed(1)} km²<br>
                            <strong>Urban Area:</strong> ${cell.urban_area.toFixed(1)} km²
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", () => {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });

                // draw inner rectangle (representing urban population)
                if (urbanAreaRatio > 0) {
                    const urbanValue = calculateValue(cell, true); // use urban value as inner rectangle color
                    const safeUrbanValue = isFinite(urbanValue) && urbanValue >= 0 ? urbanValue : 0;
                    
                    cellGroup.append("rect")
                        .attr("x", projectedPos[0] - innerRectSize/2)
                        .attr("y", projectedPos[1] - innerRectSize/2)
                        .attr("width", innerRectSize)
                        .attr("height", innerRectSize)
                        .attr("fill", colorScale(safeUrbanValue))
                        .attr("opacity", 0.9)
                        .on("mouseover", function(event) {
                            const urbanValue = calculateValue(cell, true);
                            const ruralValue = calculateValue(cell, false);
                            const valueUnit = currentConfig.colorMapping === 'population' ? '' : '/km²';
                            
                            tooltip.transition()
                                .duration(200)
                                .style("opacity", .9);
                            tooltip.html(`
                                <strong>Cell Info:</strong><br>
                                <strong>Lon:</strong> ${cell.longitude.toFixed(2)}°, 
                                <strong>Lat:</strong> ${cell.latitude.toFixed(2)}°<br>
                                <strong>Total Population:</strong> ${Math.round(cell.total_population).toLocaleString()}<br>
                                <strong>Rural Population:</strong> ${Math.round(cell.rural_population).toLocaleString()} (outer rectangle)<br>
                                <strong>Urban Population:</strong> ${Math.round(cell.urban_population).toLocaleString()} (inner rectangle, ${urbanAreaRatio.toFixed(1)}% area)<br>
                                <strong>Rural Value:</strong> ${ruralValue.toFixed(1)}${valueUnit}<br>
                                <strong>Urban Value:</strong> ${urbanValue.toFixed(1)}${valueUnit}<br>
                                <strong>Rural Area:</strong> ${cell.rural_area.toFixed(1)} km²<br>
                                <strong>Urban Area:</strong> ${cell.urban_area.toFixed(1)} km²
                            `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", () => {
                            tooltip.transition()
                                .duration(500)
                                .style("opacity", 0);
                        });
                }
            });
            
            // rebind zoom button event listener
            const resetZoomBtn = document.getElementById('resetZoomBtn');
            
            // remove old event listener, avoid duplicate binding
            if (resetZoomBtn) {
                resetZoomBtn.removeEventListener('click', resetZoom);
                resetZoomBtn.addEventListener('click', resetZoom);
            }
            
            // update zoom info
            updateZoomInfo();
        }

        // zoom control function
        function updateZoomInfo() {
            // since the zoom-info and zoom button are deleted, this function is now mainly used for updating global state
            // can be reserved for future extensions
        }
        
        function zoomIn() {
            if (zoomLevel < MAX_ZOOM) {
                const svg = d3.select("#chart svg");
                if (!svg.empty()) {
                    // get the size of SVG and current zoom state
                    const width = parseInt(svg.attr("width"));
                    const height = parseInt(svg.attr("height"));
                    const currentTransform = d3.zoomTransform(svg.node());
                    
                    // calculate new zoom scale
                    const newScale = Math.min(MAX_ZOOM, currentTransform.k * 1.5);
                    
                    // use map center as zoom center
                    const centerX = width / 2;
                    const centerY = height / 2;
                    
                    // create new transform, keep center point unchanged
                    const newTransform = d3.zoomIdentity
                        .translate(centerX, centerY)
                        .scale(newScale)
                        .translate(-centerX, -centerY);
                    
                    // apply transform
                    svg.call(d3.zoom().transform, newTransform);
                    
                    // immediately apply zoom transform to map group
                    svg.select(".map-group").attr("transform", newTransform);
                    
                    // update global zoom state
                    currentZoom = newTransform;
                    zoomLevel = newScale;
                    updateZoomInfo();
                }
            }
        }
        
        function zoomOut() {
            if (zoomLevel > MIN_ZOOM) {
                const svg = d3.select("#chart svg");
                if (!svg.empty()) {
                    // get the size of SVG and current zoom state
                    const width = parseInt(svg.attr("width"));
                    const height = parseInt(svg.attr("height"));
                    const currentTransform = d3.zoomTransform(svg.node());
                    
                    // calculate new zoom scale
                    const newScale = Math.max(MIN_ZOOM, currentTransform.k * 0.75);
                    
                    // use map center as zoom center
                    const centerX = width / 2;
                    const centerY = height / 2;
                    
                    // create new transform, keep center point unchanged
                    const newTransform = d3.zoomIdentity
                        .translate(centerX, centerY)
                        .scale(newScale)
                        .translate(-centerX, -centerY);
                    
                    // apply transform
                    svg.call(d3.zoom().transform, newTransform);
                    
                    // immediately apply zoom transform to map group
                    svg.select(".map-group").attr("transform", newTransform);
                    
                    // update global zoom state
                    currentZoom = newScale;
                    zoomLevel = newScale;
                    updateZoomInfo();
                }
            }
        }
        
        function resetZoom() {
            const svg = d3.select("#chart svg");
            if (!svg.empty()) {
                // use existing zoom behavior to reset
                svg.call(d3.zoom().transform, d3.zoomIdentity);
                
                // immediately apply zoom transform to map group
                svg.select(".map-group").attr("transform", d3.zoomIdentity);
                
                // update global zoom state
                currentZoom = d3.zoomIdentity;
                zoomLevel = 1;
                updateZoomInfo();
            }
        }
        
        // zoom button event listener
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        
        if (resetZoomBtn) resetZoomBtn.addEventListener('click', resetZoom);

        // initialize
        initChart();
        updateDetailPanelPosition(); // initialize detail panel position
        updateZoomInfo(); // initialize zoom info

        // create custom dropdown
        function createCustomSelects() {
            const selects = document.querySelectorAll('.control-group select');
            
            selects.forEach(select => {
                // create custom dropdown container
                const customSelect = document.createElement('div');
                customSelect.className = 'custom-select';
                customSelect.style.cssText = `
                    position: relative;
                    display: inline-block;
                    min-width: ${Math.max(select.offsetWidth, 80)}px;
                    font-family: inherit;
                `;
                
                // create display area
                const selectDisplay = document.createElement('div');
                selectDisplay.className = 'select-display';
                selectDisplay.style.cssText = `
                    padding: 6px 10px;
                    border: 2px solid #e9ecef;
                    border-radius: 4px;
                    background: white;
                    cursor: pointer;
                    user-select: none;
                    position: relative;
                    font-size: 13px;
                    font-weight: 500;
                    color: #374151;
                    letter-spacing: 0.025em;
                    transition: all 0.3s ease;
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
                    min-width: 80px;
                    max-width: 120px;
                `;
                
                // add dropdown arrow
                const arrow = document.createElement('span');
                arrow.innerHTML = '▼';
                arrow.style.cssText = `
                    position: absolute;
                    right: 8px;
                    top: 50%;
                    transform: translateY(-50%);
                    font-size: 10px;
                    color: #6b7280;
                    transition: transform 0.3s ease;
                `;
                
                selectDisplay.appendChild(arrow);
                selectDisplay.appendChild(document.createTextNode(select.options[select.selectedIndex].text));
                
                // create dropdown options list
                const optionsList = document.createElement('div');
                optionsList.className = 'select-options';
                optionsList.style.cssText = `
                    position: absolute;
                    top: 100%;
                    left: 0;
                    right: 0;
                    background: white;
                    border: 2px solid #e9ecef;
                    border-top: none;
                    border-radius: 0 0 4px 4px;
                    max-height: 200px;
                    overflow-y: auto;
                    z-index: 9999;
                    opacity: 0;
                    visibility: hidden;
                    transform: translateY(-10px);
                    transition: all 0.3s ease;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                `;
                
                // add options
                Array.from(select.options).forEach((option, index) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'select-option';
                    optionDiv.textContent = option.text;
                    optionDiv.style.cssText = `
                        padding: 10px 12px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        border-bottom: 1px solid #f3f4f6;
                        font-size: 13px;
                        color: #374151;
                    `;
                    
                    // hover effect
                    optionDiv.addEventListener('mouseenter', function() {
                        this.style.backgroundColor = '#f3f4f6';
                        this.style.color = '#1f2937';
                    });
                    
                    optionDiv.addEventListener('mouseleave', function() {
                        this.style.backgroundColor = 'white';
                        this.style.color = '#374151';
                    });
                    
                    // click to select
                    optionDiv.addEventListener('click', function() {
                        select.value = option.value;
                        selectDisplay.textContent = option.text;
                        selectDisplay.appendChild(arrow);
                        
                        // trigger change event
                        const event = new Event('change', { bubbles: true });
                        select.dispatchEvent(event);
                        
                        // hide options list
                        toggleOptions();
                    });
                    
                    optionsList.appendChild(optionDiv);
                });
                
                // toggle options list display/hide
                let isOpen = false;
                function toggleOptions() {
                    isOpen = !isOpen;
                    if (isOpen) {
                        optionsList.style.opacity = '1';
                        optionsList.style.visibility = 'visible';
                        optionsList.style.transform = 'translateY(0)';
                        arrow.style.transform = 'translateY(-50%) rotate(180deg)';
                        selectDisplay.style.borderColor = '#2E86AB';
                        selectDisplay.style.boxShadow = '0 0 0 3px rgba(46, 134, 171, 0.15), 0 4px 8px rgba(0, 0, 0, 0.1)';
                    } else {
                        optionsList.style.opacity = '0';
                        optionsList.style.visibility = 'hidden';
                        optionsList.style.transform = 'translateY(-10px)';
                        arrow.style.transform = 'translateY(-50%) rotate(0deg)';
                        selectDisplay.style.borderColor = '#e9ecef';
                        selectDisplay.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.05)';
                    }
                }
                
                // click display area to toggle options
                selectDisplay.addEventListener('click', toggleOptions);
                
                // hover effect
                selectDisplay.addEventListener('mouseenter', function() {
                    if (!isOpen) {
                        this.style.borderColor = '#d1d5db';
                        this.style.backgroundColor = '#fafbfc';
                        this.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
                        this.style.transform = 'translateY(-1px)';
                    }
                });
                
                selectDisplay.addEventListener('mouseleave', function() {
                    if (!isOpen) {
                        this.style.borderColor = '#e9ecef';
                        this.style.backgroundColor = 'white';
                        this.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.05)';
                        this.style.transform = 'translateY(0)';
                    }
                });
                
                // assemble custom dropdown
                customSelect.appendChild(selectDisplay);
                customSelect.appendChild(optionsList);
                
                // replace original select
                select.style.display = 'none';
                select.parentNode.insertBefore(customSelect, select);
                
                // click outside to close dropdown
                document.addEventListener('click', function(e) {
                    if (!customSelect.contains(e.target)) {
                        if (isOpen) {
                            toggleOptions();
                        }
                    }
                });
            });
        }

        // listen to window size change
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                initChart();
                updateDetailPanelPosition(); // update detail panel position when window size changes
                updateZoomInfo(); // update zoom info
                updateZoomControlsPosition(); // update zoom controls position when window size changes
            }, 250);
        });
        
        // create custom dropdown after page load
        window.addEventListener('load', function() {
            setTimeout(createCustomSelects, 100);
            updateZoomControlsPosition(); // Initialize zoom controls position
            setupCollapseControls(); // Initialize collapse controls functionality
        });
    </script>
</body>
</html> 
